---
phase: 12-devops-tests
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - .github/workflows/ci.yml
  - .github/workflows/deploy.yml
autonomous: true

must_haves:
  truths:
    - "CI pipeline runs on every push to main and PRs"
    - "Tests run in CI with pytest"
    - "Linting runs in CI (flake8)"
    - "Docker image builds successfully in CI"
    - "Deployment to Cloud Run triggers on main branch merge"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Continuous Integration workflow"
      min_lines: 40
    - path: ".github/workflows/deploy.yml"
      provides: "Cloud Run deployment workflow"
      min_lines: 50
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "tests/"
      via: "pytest command"
      pattern: "pytest"
    - from: ".github/workflows/deploy.yml"
      to: "Dockerfile"
      via: "docker build"
      pattern: "docker build"
---

<objective>
Create GitHub Actions CI/CD pipeline for automated testing and deployment.

Purpose: Automated CI/CD ensures every change is tested before merge and deployments are consistent. This eliminates "works on my machine" issues and enforces code quality standards.

Output: Two GitHub Actions workflows - ci.yml for testing on PRs, deploy.yml for deploying to Cloud Run on main branch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Dockerfile
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CI workflow for testing</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Create .github/workflows directory if it doesn't exist, then create ci.yml:

```yaml
name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run linting
        run: |
          flake8 src/ tests/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src/ tests/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Run tests
        run: |
          pytest tests/ -v --tb=short
        env:
          PYTHONPATH: ${{ github.workspace }}

  docker-build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: test-build:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

Key features:
- Runs on push to main/master and PRs
- Separate jobs for test and docker-build (run in parallel)
- Python 3.11 with pip caching for speed
- Flake8 linting (critical errors fail, style warnings don't)
- Pytest with verbose output
- Docker build verification (ensures image builds)
  </action>
  <verify>
File exists at .github/workflows/ci.yml with valid YAML syntax.
```bash
# Validate YAML syntax
python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"
```
  </verify>
  <done>
ci.yml workflow created with test job (Python 3.11, lint, pytest) and docker-build job, triggers on push/PR to main.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deployment workflow for Cloud Run</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
Create deploy.yml for deploying to Google Cloud Run:

```yaml
name: Deploy to Cloud Run

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main, master]
  workflow_dispatch:  # Allow manual trigger

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: multitenant-ai-platform
  REGION: us-central1

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only deploy if CI workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

      - name: Build and push Docker image
        run: |
          IMAGE_TAG="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }}"
          docker build -t $IMAGE_TAG .
          docker push $IMAGE_TAG
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image ${{ env.IMAGE_TAG }} \
            --region ${{ env.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --memory 2Gi \
            --cpu 2 \
            --min-instances 0 \
            --max-instances 10 \
            --timeout 300 \
            --set-env-vars "LOG_LEVEL=INFO"

      - name: Show deployment URL
        run: |
          URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region ${{ env.REGION }} --format 'value(status.url)')
          echo "Deployed to: $URL"
          echo "::notice title=Deployment URL::$URL"
```

Required secrets (documented in comments):
- GCP_PROJECT_ID: Google Cloud project ID
- WIF_PROVIDER: Workload Identity Federation provider
- WIF_SERVICE_ACCOUNT: Service account email for deployment

Note: Uses Workload Identity Federation (recommended) instead of service account keys for security.
  </action>
  <verify>
File exists at .github/workflows/deploy.yml with valid YAML syntax.
```bash
python -c "import yaml; yaml.safe_load(open('.github/workflows/deploy.yml'))"
```
  </verify>
  <done>
deploy.yml workflow created with GCP authentication, Docker build/push to Artifact Registry, Cloud Run deployment, triggers on push to main.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add workflow documentation and secrets guide</name>
  <files>.github/workflows/README.md</files>
  <action>
Create a README documenting the workflows and required secrets:

```markdown
# GitHub Actions Workflows

## CI Workflow (ci.yml)

Runs on every push to main/master and on pull requests.

### Jobs

1. **test**: Runs Python tests
   - Python 3.11
   - Linting with flake8
   - Tests with pytest

2. **docker-build**: Verifies Docker image builds
   - Uses BuildKit caching for speed
   - Does not push (verification only)

## Deploy Workflow (deploy.yml)

Deploys to Google Cloud Run on push to main/master.

### Required Secrets

Set these in GitHub repository settings (Settings > Secrets and variables > Actions):

| Secret | Description | Example |
|--------|-------------|---------|
| `GCP_PROJECT_ID` | Google Cloud project ID | `my-project-123456` |
| `WIF_PROVIDER` | Workload Identity provider | `projects/123456/locations/global/workloadIdentityPools/github/providers/github` |
| `WIF_SERVICE_ACCOUNT` | Service account email | `github-deploy@my-project.iam.gserviceaccount.com` |

### Setting up Workload Identity Federation

1. Create a Workload Identity Pool:
   ```bash
   gcloud iam workload-identity-pools create "github" \
     --location="global" \
     --display-name="GitHub Actions"
   ```

2. Create a Provider in the pool:
   ```bash
   gcloud iam workload-identity-pools providers create-oidc "github" \
     --location="global" \
     --workload-identity-pool="github" \
     --display-name="GitHub" \
     --attribute-mapping="google.subject=assertion.sub,attribute.actor=assertion.actor,attribute.repository=assertion.repository" \
     --issuer-uri="https://token.actions.githubusercontent.com"
   ```

3. Create a service account and grant permissions:
   ```bash
   gcloud iam service-accounts create github-deploy \
     --display-name="GitHub Deploy"

   gcloud projects add-iam-policy-binding PROJECT_ID \
     --member="serviceAccount:github-deploy@PROJECT_ID.iam.gserviceaccount.com" \
     --role="roles/run.admin"

   gcloud projects add-iam-policy-binding PROJECT_ID \
     --member="serviceAccount:github-deploy@PROJECT_ID.iam.gserviceaccount.com" \
     --role="roles/artifactregistry.writer"
   ```

4. Allow the service account to be impersonated:
   ```bash
   gcloud iam service-accounts add-iam-policy-binding \
     github-deploy@PROJECT_ID.iam.gserviceaccount.com \
     --role="roles/iam.workloadIdentityUser" \
     --member="principalSet://iam.googleapis.com/projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/github/attribute.repository/OWNER/REPO"
   ```

## Manual Deployment

The deploy workflow can also be triggered manually via the GitHub Actions UI (workflow_dispatch).
```
  </action>
  <verify>
README.md exists at .github/workflows/README.md with setup instructions.
  </verify>
  <done>
README.md created with workflow documentation, required secrets list, and Workload Identity Federation setup guide.
  </done>
</task>

</tasks>

<verification>
- [ ] .github/workflows/ci.yml exists with valid YAML
- [ ] .github/workflows/deploy.yml exists with valid YAML
- [ ] .github/workflows/README.md documents required secrets
- [ ] CI workflow tests Python code with pytest
- [ ] Deploy workflow uses Workload Identity Federation (no service account keys)
</verification>

<success_criteria>
1. CI workflow runs tests and linting on every PR
2. CI workflow verifies Docker build succeeds
3. Deploy workflow triggers on main branch push
4. Deploy workflow uses secure authentication (Workload Identity Federation)
5. Documentation explains required secrets setup
</success_criteria>

<output>
After completion, create `.planning/phases/12-devops-tests/12-03-SUMMARY.md`
</output>
