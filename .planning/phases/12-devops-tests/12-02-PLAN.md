---
phase: 12-devops-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/structured_logger.py
  - main.py
  - src/middleware/request_id_middleware.py
autonomous: true

must_haves:
  truths:
    - "Every log entry includes a request_id for tracing"
    - "Log format is JSON (machine-parseable)"
    - "Request ID is passed to downstream services/logs"
    - "Request ID header is returned in response"
  artifacts:
    - path: "src/utils/structured_logger.py"
      provides: "JSON-formatted structured logging"
      min_lines: 50
    - path: "src/middleware/request_id_middleware.py"
      provides: "Request ID generation and propagation"
      min_lines: 30
  key_links:
    - from: "main.py"
      to: "src/middleware/request_id_middleware.py"
      via: "middleware registration"
      pattern: "add_middleware.*RequestIdMiddleware"
    - from: "src/utils/structured_logger.py"
      to: "request context"
      via: "contextvars"
      pattern: "contextvars"
---

<objective>
Add structured logging with request ID tracing for production debugging.

Purpose: In a distributed system, tracing requests across services is critical for debugging. Every log entry needs a unique request ID so we can correlate logs from a single request. JSON format enables log aggregation tools (Cloud Logging, Datadog, etc.) to parse and search logs.

Output: Structured JSON logging with request ID in every log entry, request ID middleware, and updated main.py to use the new logging setup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured logger with JSON output</name>
  <files>src/utils/structured_logger.py</files>
  <action>
Create a structured logging module that:
1. Uses Python's logging with custom JSON formatter
2. Uses contextvars to store request_id for the current request
3. Provides a get_logger() function that returns a logger with request_id injected
4. Formats logs as JSON with: timestamp, level, logger, message, request_id, extra fields

Example implementation:
```python
import logging
import json
import sys
from datetime import datetime
from contextvars import ContextVar
from typing import Optional, Any

# Context variable to hold current request ID
request_id_var: ContextVar[Optional[str]] = ContextVar('request_id', default=None)

def set_request_id(request_id: str) -> None:
    """Set request ID for current context."""
    request_id_var.set(request_id)

def get_request_id() -> Optional[str]:
    """Get request ID for current context."""
    return request_id_var.get()

class JSONFormatter(logging.Formatter):
    """JSON log formatter with request_id injection."""

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "request_id": get_request_id(),
        }

        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        # Add any extra fields
        if hasattr(record, 'extra_fields'):
            log_data.update(record.extra_fields)

        return json.dumps(log_data)

def setup_structured_logging(level: str = "INFO") -> None:
    """Configure structured JSON logging for the application."""
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, level.upper()))

    # Remove existing handlers
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # Add JSON handler to stdout
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(JSONFormatter())
    root_logger.addHandler(handler)

def get_logger(name: str) -> logging.Logger:
    """Get a logger instance."""
    return logging.getLogger(name)

class StructuredLoggerAdapter(logging.LoggerAdapter):
    """Logger adapter that includes extra context in logs."""

    def process(self, msg, kwargs):
        extra = kwargs.get('extra', {})
        extra['request_id'] = get_request_id()
        kwargs['extra'] = extra
        return msg, kwargs
```

Key points:
- Use contextvars for thread-safe request ID storage (works with async)
- JSON output for machine parsing
- Include timestamp, level, logger name, message, request_id in every log
- Handle exceptions properly
  </action>
  <verify>
```python
# Quick test
from src.utils.structured_logger import setup_structured_logging, get_logger, set_request_id
setup_structured_logging()
set_request_id("test-123")
logger = get_logger(__name__)
logger.info("Test message")
# Should output: {"timestamp": "...", "level": "INFO", "logger": "...", "message": "Test message", "request_id": "test-123"}
```
  </verify>
  <done>
structured_logger.py exists with JSONFormatter class, request_id contextvars, setup_structured_logging() function, and get_logger() function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create request ID middleware</name>
  <files>src/middleware/request_id_middleware.py</files>
  <action>
Create middleware that:
1. Generates a unique request ID (UUID4) for each request
2. Checks for incoming X-Request-ID header (for distributed tracing)
3. Sets the request_id in contextvars for logging
4. Adds X-Request-ID to response headers

```python
import uuid
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response
from src.utils.structured_logger import set_request_id, get_logger

logger = get_logger(__name__)

class RequestIdMiddleware(BaseHTTPMiddleware):
    """Middleware to generate and propagate request IDs."""

    async def dispatch(self, request: Request, call_next) -> Response:
        # Get existing request ID from header or generate new one
        request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())

        # Set in contextvars for logging
        set_request_id(request_id)

        # Store in request state for access in route handlers
        request.state.request_id = request_id

        # Log request start
        logger.info(f"Request started: {request.method} {request.url.path}")

        # Process request
        response = await call_next(request)

        # Add request ID to response headers
        response.headers["X-Request-ID"] = request_id

        # Log request completion
        logger.info(f"Request completed: {response.status_code}")

        return response
```

Note: This middleware should be added EARLY in the middleware chain (added LAST in FastAPI since middleware runs in reverse order) so that all other middleware and route handlers have access to the request ID.
  </action>
  <verify>
Middleware file exists at src/middleware/request_id_middleware.py with RequestIdMiddleware class.
  </verify>
  <done>
RequestIdMiddleware created, generates UUID4 request IDs, checks X-Request-ID header, sets contextvars, adds to response headers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate structured logging in main.py</name>
  <files>main.py</files>
  <action>
Update main.py to:
1. Import and call setup_structured_logging() early in startup
2. Add RequestIdMiddleware to the middleware chain (add LAST so it runs FIRST)
3. Replace existing logging.basicConfig with structured logging setup
4. Keep existing middleware order intact

Changes to main.py:
```python
# At the top, after imports
from src.utils.structured_logger import setup_structured_logging, get_logger

# Replace logging.basicConfig with:
log_level = os.getenv("LOG_LEVEL", "INFO")
setup_structured_logging(log_level)
logger = get_logger(__name__)

# After CORS middleware (at the very end of middleware setup)
from src.middleware.request_id_middleware import RequestIdMiddleware
app.add_middleware(RequestIdMiddleware)  # Added LAST = runs FIRST
```

Important: The RequestIdMiddleware must be the LAST middleware added so it runs FIRST (before any logging happens in other middleware).
  </action>
  <verify>
Run the application and make a request:
```bash
curl -v http://localhost:8000/health
```
Check:
1. Response includes X-Request-ID header
2. Logs are JSON formatted
3. Logs include request_id field
  </verify>
  <done>
main.py uses structured logging, RequestIdMiddleware is registered, logs are JSON format with request_id in every entry, X-Request-ID header returned in responses.
  </done>
</task>

</tasks>

<verification>
- [ ] Logs are JSON formatted (parseable by jq)
- [ ] Every log entry includes request_id field
- [ ] X-Request-ID header present in all responses
- [ ] Incoming X-Request-ID is preserved (for distributed tracing)
- [ ] Application still works correctly (no logging regressions)
</verification>

<success_criteria>
1. All logs are JSON formatted with timestamp, level, logger, message, request_id
2. Every request gets a unique request ID (UUID4)
3. Request ID is included in response headers (X-Request-ID)
4. Request ID is propagated to all logs within a request
5. Existing X-Request-ID header is respected for distributed tracing
</success_criteria>

<output>
After completion, create `.planning/phases/12-devops-tests/12-02-SUMMARY.md`
</output>
