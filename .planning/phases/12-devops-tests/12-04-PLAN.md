---
phase: 12-devops-tests
plan: 04
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - pyproject.toml
  - tests/test_api_routes.py
  - tests/test_services.py
  - tests/test_middleware.py
autonomous: true

must_haves:
  truths:
    - "Test coverage is at least 70%"
    - "Critical paths (auth, tenant isolation) have tests"
    - "API endpoints have basic request/response tests"
    - "Coverage report is generated in CI"
  artifacts:
    - path: "pyproject.toml"
      provides: "Pytest and coverage configuration"
      contains: "[tool.pytest.ini_options]"
    - path: "tests/test_api_routes.py"
      provides: "API route tests"
      min_lines: 100
    - path: "tests/test_services.py"
      provides: "Service layer tests"
      min_lines: 100
  key_links:
    - from: "tests/test_api_routes.py"
      to: "src/api/"
      via: "TestClient"
      pattern: "TestClient"
    - from: "tests/test_services.py"
      to: "src/services/"
      via: "import"
      pattern: "from src.services"
---

<objective>
Expand test coverage to 70% target with focused tests on critical paths.

Purpose: Test coverage ensures code quality and prevents regressions. The 70% target focuses on critical paths (auth, tenant isolation, core API endpoints) rather than pursuing 100% coverage of less critical code.

Output: Pytest configuration, new test files for API routes and services, coverage reaching 70%.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/test_auth_middleware.py
@tests/test_rate_limiter.py
@tests/test_tenant_config_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pytest configuration in pyproject.toml</name>
  <files>pyproject.toml</files>
  <action>
Create pyproject.toml with pytest and coverage configuration:

```toml
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
asyncio_mode = "auto"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
]
addopts = "-v --tb=short"

[tool.coverage.run]
source = ["src", "main.py", "config"]
omit = [
    "tests/*",
    "*/__pycache__/*",
    "*/site-packages/*",
    "venv/*",
]
branch = true

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]
fail_under = 70
show_missing = true

[tool.coverage.html]
directory = "htmlcov"
```

This configuration:
- Sets test directory to tests/
- Enables async mode for pytest-asyncio
- Configures coverage to track src/, main.py, config/
- Excludes test files and virtual env from coverage
- Sets 70% minimum coverage (fail_under = 70)
- Shows missing lines in report
  </action>
  <verify>
```bash
pytest --version
pytest tests/ -v --cov=src --cov=main --cov-report=term-missing
```
Coverage report should be generated.
  </verify>
  <done>
pyproject.toml exists with [tool.pytest.ini_options] and [tool.coverage.*] sections, coverage fail_under set to 70.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API route tests</name>
  <files>tests/test_api_routes.py</files>
  <action>
Create comprehensive API route tests using FastAPI TestClient:

```python
"""
API Route Tests

Tests for core API endpoints:
- Health endpoints
- Auth routes
- Quote routes
- Invoice routes
- Client info routes

Uses FastAPI TestClient for synchronous testing.
"""

import pytest
from unittest.mock import patch, MagicMock, AsyncMock
from fastapi.testclient import TestClient

# Import app
from main import app


class TestHealthEndpoints:
    """Test health check endpoints."""

    def test_root_returns_api_info(self):
        """GET / should return API info."""
        client = TestClient(app)
        response = client.get("/")

        assert response.status_code == 200
        data = response.json()
        assert "name" in data
        assert "version" in data
        assert "status" in data
        assert data["status"] == "running"

    def test_health_returns_healthy(self):
        """GET /health should return healthy status."""
        client = TestClient(app)
        response = client.get("/health")

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        assert "timestamp" in data

    def test_health_live_returns_alive(self):
        """GET /health/live should return alive status."""
        client = TestClient(app)
        response = client.get("/health/live")

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "alive"


class TestAuthRoutes:
    """Test authentication routes."""

    def test_login_without_credentials_returns_422(self):
        """POST /api/v1/auth/login without body returns 422."""
        client = TestClient(app)
        response = client.post("/api/v1/auth/login")

        assert response.status_code == 422  # Validation error

    def test_login_with_invalid_credentials(self):
        """POST /api/v1/auth/login with invalid credentials."""
        client = TestClient(app)

        with patch('src.api.auth_routes.AuthService') as MockAuthService:
            mock_instance = MagicMock()
            mock_instance.login.return_value = (False, None, "Invalid credentials")
            MockAuthService.return_value = mock_instance

            response = client.post(
                "/api/v1/auth/login",
                json={"email": "test@example.com", "password": "wrongpassword"},
                headers={"X-Client-ID": "africastay"}
            )

            assert response.status_code == 401

    def test_refresh_without_token_returns_401(self):
        """POST /api/v1/auth/refresh without token returns 401."""
        client = TestClient(app)
        response = client.post("/api/v1/auth/refresh")

        # Should fail - no refresh token provided
        assert response.status_code in [401, 422]


class TestClientInfoRoute:
    """Test client info endpoint."""

    def test_client_info_returns_tenant_data(self):
        """GET /api/v1/client/info returns tenant information."""
        client = TestClient(app)

        with patch('main.get_config') as mock_config:
            mock_config.return_value = MagicMock(
                client_id='test_tenant',
                company_name='Test Company',
                currency='USD',
                timezone='UTC',
                destination_names=['Beach', 'Safari'],
                primary_color='#000000',
                secondary_color='#ffffff',
                logo_url='https://example.com/logo.png',
                primary_email='test@example.com',
                sendgrid_from_email='noreply@example.com',
                sendgrid_from_name='Test Company',
                sendgrid_reply_to='reply@example.com',
                bank_name='Test Bank',
                bank_account_name='Test Account',
                bank_account_number='123456789',
                bank_branch_code='001',
                bank_swift_code='TESTSWFT',
                payment_reference_prefix='INV',
            )

            with patch('main.SupabaseTool') as MockSupabase:
                mock_db = MagicMock()
                mock_db.get_tenant_settings.return_value = {}
                MockSupabase.return_value = mock_db

                response = client.get(
                    "/api/v1/client/info",
                    headers={"X-Client-ID": "test_tenant"}
                )

                assert response.status_code == 200
                data = response.json()
                assert data["success"] is True
                assert "data" in data


class TestProtectedRoutes:
    """Test that protected routes require authentication."""

    def test_quotes_requires_auth(self):
        """GET /api/v1/quotes requires authentication."""
        client = TestClient(app)
        response = client.get("/api/v1/quotes")

        assert response.status_code == 401

    def test_invoices_requires_auth(self):
        """GET /api/v1/invoices requires authentication."""
        client = TestClient(app)
        response = client.get("/api/v1/invoices")

        assert response.status_code == 401

    def test_clients_requires_auth(self):
        """GET /api/v1/clients requires authentication."""
        client = TestClient(app)
        response = client.get("/api/v1/clients")

        assert response.status_code == 401


class TestCORSHeaders:
    """Test CORS headers are present."""

    def test_options_request_returns_cors_headers(self):
        """OPTIONS request should return CORS headers."""
        client = TestClient(app)
        response = client.options(
            "/api/v1/quotes",
            headers={"Origin": "http://localhost:5173"}
        )

        # Should not be blocked by auth (OPTIONS is exempt)
        assert "access-control-allow-origin" in response.headers or response.status_code == 200


class TestRateLimitHeaders:
    """Test rate limit headers are present."""

    def test_api_routes_have_rate_limit_headers(self):
        """API routes should include rate limit headers."""
        client = TestClient(app)

        # Health endpoint is exempted from rate limiting
        # Use a protected endpoint that will return 401 but still have headers
        response = client.get("/api/v1/quotes")

        # Rate limit headers should be present even on 401
        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Key points:
- Use TestClient for synchronous HTTP testing
- Mock external dependencies (AuthService, SupabaseTool, config)
- Test both success and error cases
- Verify protected routes require auth
- Check CORS and rate limit headers
  </action>
  <verify>
```bash
pytest tests/test_api_routes.py -v
```
All tests should pass.
  </verify>
  <done>
test_api_routes.py created with tests for health endpoints, auth routes, client info, protected routes, CORS, and rate limit headers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create service layer tests</name>
  <files>tests/test_services.py</files>
  <action>
Create tests for critical service classes:

```python
"""
Service Layer Tests

Tests for:
- AuthService
- CRMService
- ProvisioningService
"""

import pytest
from unittest.mock import patch, MagicMock, AsyncMock
import os


class TestAuthService:
    """Test AuthService functionality."""

    def test_auth_service_initializes(self):
        """AuthService should initialize with config."""
        from src.services.auth_service import AuthService

        mock_config = MagicMock()
        mock_config.supabase_url = 'https://test.supabase.co'
        mock_config.supabase_anon_key = 'test-anon-key'
        mock_config.supabase_service_key = 'test-service-key'
        mock_config.client_id = 'test_tenant'

        with patch.dict(os.environ, {'JWT_SECRET': 'test-secret'}):
            service = AuthService(mock_config)
            assert service is not None
            assert service.config == mock_config

    def test_verify_jwt_with_valid_token(self):
        """verify_jwt should return True for valid token."""
        from src.services.auth_service import AuthService
        import jwt

        mock_config = MagicMock()
        mock_config.supabase_url = 'https://test.supabase.co'
        mock_config.supabase_anon_key = 'test-anon-key'
        mock_config.supabase_service_key = 'test-service-key'
        mock_config.client_id = 'test_tenant'

        secret = 'test-secret-key'
        with patch.dict(os.environ, {'JWT_SECRET': secret}):
            service = AuthService(mock_config)

            # Create a valid token
            token = jwt.encode({'sub': 'user123', 'exp': 9999999999}, secret, algorithm='HS256')

            valid, payload = service.verify_jwt(token)

            assert valid is True
            assert payload['sub'] == 'user123'

    def test_verify_jwt_with_expired_token(self):
        """verify_jwt should return False for expired token."""
        from src.services.auth_service import AuthService
        import jwt

        mock_config = MagicMock()
        mock_config.supabase_url = 'https://test.supabase.co'
        mock_config.supabase_anon_key = 'test-anon-key'
        mock_config.supabase_service_key = 'test-service-key'
        mock_config.client_id = 'test_tenant'

        secret = 'test-secret-key'
        with patch.dict(os.environ, {'JWT_SECRET': secret}):
            service = AuthService(mock_config)

            # Create an expired token
            token = jwt.encode({'sub': 'user123', 'exp': 1}, secret, algorithm='HS256')

            valid, payload = service.verify_jwt(token)

            assert valid is False

    def test_verify_jwt_with_invalid_token(self):
        """verify_jwt should return False for invalid token."""
        from src.services.auth_service import AuthService

        mock_config = MagicMock()
        mock_config.supabase_url = 'https://test.supabase.co'
        mock_config.supabase_anon_key = 'test-anon-key'
        mock_config.supabase_service_key = 'test-service-key'
        mock_config.client_id = 'test_tenant'

        with patch.dict(os.environ, {'JWT_SECRET': 'test-secret'}):
            service = AuthService(mock_config)

            valid, payload = service.verify_jwt("invalid.token.here")

            assert valid is False


class TestCRMService:
    """Test CRMService functionality."""

    def test_crm_service_initializes(self):
        """CRMService should initialize with config."""
        from src.services.crm_service import CRMService

        mock_config = MagicMock()
        mock_config.client_id = 'test_tenant'

        service = CRMService(mock_config)
        assert service is not None

    def test_format_phone_number(self):
        """Test phone number formatting."""
        from src.services.crm_service import CRMService

        mock_config = MagicMock()
        mock_config.client_id = 'test_tenant'

        service = CRMService(mock_config)

        # Test various phone formats (if method exists)
        if hasattr(service, '_format_phone'):
            # Add specific tests based on implementation
            pass


class TestProvisioningService:
    """Test tenant provisioning functionality."""

    def test_provisioning_service_exists(self):
        """ProvisioningService should be importable."""
        from src.services.provisioning_service import ProvisioningService
        assert ProvisioningService is not None


class TestTenantConfigService:
    """Additional tests for TenantConfigService not covered in existing tests."""

    def test_get_supabase_client_returns_client(self):
        """_get_supabase_client should return Supabase client."""
        from src.services.tenant_config_service import TenantConfigService

        service = TenantConfigService()

        with patch.dict(os.environ, {
            'SUPABASE_URL': 'https://test.supabase.co',
            'SUPABASE_SERVICE_KEY': 'test-key'
        }):
            with patch('src.services.tenant_config_service.create_client') as mock_create:
                mock_create.return_value = MagicMock()
                client = service._get_supabase_client()
                # Should attempt to create client
                mock_create.assert_called_once()

    def test_config_source_tracking(self):
        """Config should track whether it came from DB or YAML."""
        from src.services.tenant_config_service import TenantConfigService

        service = TenantConfigService()

        # Test meta tracking
        db_config = {'client': {'id': 'test'}, '_meta': {'source': 'database'}}
        yaml_config = {'client': {'id': 'test'}, '_meta': {'source': 'yaml'}}

        assert db_config['_meta']['source'] == 'database'
        assert yaml_config['_meta']['source'] == 'yaml'


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Focus on:
- AuthService JWT verification (critical for security)
- Service initialization
- Error handling
- Mock external dependencies (Supabase)
  </action>
  <verify>
```bash
pytest tests/test_services.py -v
```
All tests should pass.
  </verify>
  <done>
test_services.py created with tests for AuthService (JWT verification), CRMService, ProvisioningService, and TenantConfigService.
  </done>
</task>

</tasks>

<verification>
- [ ] pyproject.toml has pytest and coverage configuration
- [ ] test_api_routes.py tests critical API endpoints
- [ ] test_services.py tests critical service classes
- [ ] All existing tests still pass
- [ ] Coverage report shows >= 70% (run: `pytest --cov=src --cov-report=term-missing`)
</verification>

<success_criteria>
1. pyproject.toml configures pytest and coverage with fail_under=70
2. New test files cover API routes and services
3. All tests pass (existing + new)
4. Coverage reaches 70% target
5. Coverage report is generated successfully
</success_criteria>

<output>
After completion, create `.planning/phases/12-devops-tests/12-04-SUMMARY.md`
</output>
