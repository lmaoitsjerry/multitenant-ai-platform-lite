---
phase: 09-critical-security
plan: 03
type: execute
wave: 2
depends_on:
  - "09-01"
files_modified:
  - tests/test_auth_middleware.py
autonomous: true

must_haves:
  truths:
    - "Unit tests verify tenant spoofing attempts are rejected with 403"
    - "Unit tests verify valid requests (matching header) succeed"
    - "Unit tests verify requests without X-Client-ID header use user's tenant"
    - "Tests are runnable with pytest"
  artifacts:
    - path: "tests/test_auth_middleware.py"
      provides: "Auth middleware unit tests"
      min_lines: 100
      contains: "test_tenant_spoofing"
  key_links:
    - from: "tests/test_auth_middleware.py"
      to: "src/middleware/auth_middleware.py"
      via: "import and test"
      pattern: "from src.middleware.auth_middleware import"
---

<objective>
Create unit tests for auth middleware X-Client-ID validation to ensure tenant spoofing is properly rejected.

Purpose: TEST-01 - Verify the security fix from plan 09-01 works correctly and will catch regressions. Tests provide documentation of expected behavior and prevent future bugs.

Output: New test file tests/test_auth_middleware.py with comprehensive auth middleware tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-critical-security/09-01-SUMMARY.md
@src/middleware/auth_middleware.py
@tests/test_integration_tenant_isolation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for X-Client-ID tenant validation</name>
  <files>tests/test_auth_middleware.py</files>
  <action>
Create tests/test_auth_middleware.py with unit tests for the auth middleware tenant validation.

Follow the existing test patterns from tests/test_integration_tenant_isolation.py (pytest style with fixtures and mocking).

Test file structure:
```python
"""
Unit Tests for Auth Middleware

Tests for the AuthMiddleware class, specifically:
1. X-Client-ID header validation against JWT user's tenant
2. Tenant spoofing rejection (header != user's tenant)
3. Normal flow when header matches or is absent
4. Public path bypass

These tests verify SEC-02 security fix for tenant isolation.
"""

import pytest
import sys
from pathlib import Path
from unittest.mock import patch, MagicMock, AsyncMock
from starlette.testclient import TestClient
from starlette.responses import JSONResponse

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))


class MockUser:
    """Mock user from database"""
    def __init__(self, tenant_id='tenant_a', user_id='user_123', is_active=True):
        self.data = {
            'id': user_id,
            'email': f'{user_id}@{tenant_id}.com',
            'name': 'Test User',
            'role': 'admin',
            'tenant_id': tenant_id,
            'is_active': is_active
        }

    def to_dict(self):
        return self.data


class MockConfig:
    """Mock ClientConfig"""
    def __init__(self, tenant_id='tenant_a'):
        self.client_id = tenant_id
        self.supabase_url = 'https://test.supabase.co'
        self.supabase_service_key = 'test-service-key'


@pytest.fixture
def mock_auth_service():
    """Fixture for mocked AuthService"""
    with patch('src.middleware.auth_middleware.AuthService') as mock:
        auth_instance = MagicMock()
        mock.return_value = auth_instance
        yield auth_instance


@pytest.fixture
def mock_config():
    """Fixture for mocked get_config"""
    with patch('src.middleware.auth_middleware.get_config') as mock:
        mock.return_value = MockConfig('tenant_a')
        yield mock


class TestTenantSpoofingRejection:
    """Test that tenant spoofing attempts are rejected"""

    @pytest.mark.asyncio
    async def test_mismatched_tenant_header_returns_403(self, mock_auth_service, mock_config):
        """
        Test: User from tenant_a sends X-Client-ID: tenant_b
        Expected: 403 Forbidden with "tenant mismatch" message

        This is the core SEC-02 security test.
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        # Setup: User belongs to tenant_a but header says tenant_b
        mock_auth_service.verify_jwt.return_value = (True, {'sub': 'auth_user_123'})
        mock_auth_service.get_user_by_auth_id = AsyncMock(return_value=MockUser('tenant_a').data)

        middleware = AuthMiddleware(app=MagicMock())

        # Create mock request with spoofed header
        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',  # Protected path
            'headers': [
                (b'authorization', b'Bearer valid.jwt.token'),
                (b'x-client-id', b'tenant_b'),  # SPOOFED - user is in tenant_a
            ]
        }
        request = Request(scope)

        async def call_next(req):
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        # Should be 403 Forbidden, not 200
        assert response.status_code == 403
        # Response body should mention tenant mismatch
        body = response.body.decode() if hasattr(response, 'body') else ''
        assert 'tenant' in body.lower() or 'mismatch' in body.lower() or 'denied' in body.lower()

    @pytest.mark.asyncio
    async def test_matching_tenant_header_succeeds(self, mock_auth_service, mock_config):
        """
        Test: User from tenant_a sends X-Client-ID: tenant_a
        Expected: Request proceeds normally
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        # Setup: User belongs to tenant_a and header says tenant_a
        mock_auth_service.verify_jwt.return_value = (True, {'sub': 'auth_user_123'})
        mock_auth_service.get_user_by_auth_id = AsyncMock(return_value=MockUser('tenant_a').data)

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',
            'headers': [
                (b'authorization', b'Bearer valid.jwt.token'),
                (b'x-client-id', b'tenant_a'),  # Matches user's tenant
            ]
        }
        request = Request(scope)

        call_next_called = False
        async def call_next(req):
            nonlocal call_next_called
            call_next_called = True
            # Verify user context was set
            assert hasattr(req.state, 'user')
            assert req.state.user.tenant_id == 'tenant_a'
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == 200
        assert call_next_called

    @pytest.mark.asyncio
    async def test_no_tenant_header_uses_user_tenant(self, mock_auth_service, mock_config):
        """
        Test: User from tenant_a sends request without X-Client-ID header
        Expected: Falls back to default, user lookup happens, proceeds if user found
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        # Setup user lookup to work with default tenant
        mock_config.return_value = MockConfig('africastay')  # Default tenant
        mock_auth_service.verify_jwt.return_value = (True, {'sub': 'auth_user_123'})
        mock_auth_service.get_user_by_auth_id = AsyncMock(return_value=MockUser('africastay').data)

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',
            'headers': [
                (b'authorization', b'Bearer valid.jwt.token'),
                # NO x-client-id header
            ]
        }
        request = Request(scope)

        async def call_next(req):
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        # Should succeed (user exists in default tenant)
        assert response.status_code == 200


class TestPublicPathBypass:
    """Test that public paths bypass auth"""

    @pytest.mark.asyncio
    async def test_public_paths_skip_auth(self):
        """
        Test: Request to /health endpoint
        Expected: Auth middleware skips validation, request proceeds
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/health',  # Public path
            'headers': []  # No auth headers needed
        }
        request = Request(scope)

        call_next_called = False
        async def call_next(req):
            nonlocal call_next_called
            call_next_called = True
            # User should be None for public paths
            assert req.state.user is None
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == 200
        assert call_next_called

    @pytest.mark.asyncio
    async def test_admin_routes_use_token_auth(self):
        """
        Test: /api/v1/admin/* routes are public (use X-Admin-Token auth)
        Expected: Middleware skips JWT auth for admin routes
        """
        from src.middleware.auth_middleware import is_public_path

        assert is_public_path('/api/v1/admin/tenants') == True
        assert is_public_path('/api/v1/admin/analytics/overview') == True


class TestMissingAuth:
    """Test requests missing authentication"""

    @pytest.mark.asyncio
    async def test_missing_auth_header_returns_401(self):
        """
        Test: Protected path without Authorization header
        Expected: 401 Unauthorized
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',  # Protected path
            'headers': [
                (b'x-client-id', b'tenant_a'),
                # NO authorization header
            ]
        }
        request = Request(scope)

        async def call_next(req):
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == 401

    @pytest.mark.asyncio
    async def test_invalid_jwt_returns_401(self, mock_auth_service, mock_config):
        """
        Test: Protected path with invalid JWT
        Expected: 401 Unauthorized
        """
        from src.middleware.auth_middleware import AuthMiddleware
        from starlette.requests import Request
        from starlette.responses import Response

        # Setup: JWT verification fails
        mock_auth_service.verify_jwt.return_value = (False, {'error': 'Token expired'})

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',
            'headers': [
                (b'authorization', b'Bearer invalid.jwt.token'),
                (b'x-client-id', b'tenant_a'),
            ]
        }
        request = Request(scope)

        async def call_next(req):
            return Response(content='OK', status_code=200)

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == 401


class TestUserContext:
    """Test UserContext creation"""

    @pytest.mark.asyncio
    async def test_user_context_populated_correctly(self, mock_auth_service, mock_config):
        """
        Test: Valid auth request
        Expected: UserContext has correct tenant_id, role, email
        """
        from src.middleware.auth_middleware import AuthMiddleware, UserContext
        from starlette.requests import Request
        from starlette.responses import Response

        user_data = {
            'id': 'user_123',
            'email': 'admin@tenant_a.com',
            'name': 'Admin User',
            'role': 'admin',
            'tenant_id': 'tenant_a',
            'is_active': True
        }

        mock_auth_service.verify_jwt.return_value = (True, {'sub': 'auth_user_123'})
        mock_auth_service.get_user_by_auth_id = AsyncMock(return_value=user_data)

        middleware = AuthMiddleware(app=MagicMock())

        scope = {
            'type': 'http',
            'method': 'GET',
            'path': '/api/v1/quotes',
            'headers': [
                (b'authorization', b'Bearer valid.jwt.token'),
                (b'x-client-id', b'tenant_a'),
            ]
        }
        request = Request(scope)

        captured_user = None
        async def call_next(req):
            nonlocal captured_user
            captured_user = req.state.user
            return Response(content='OK', status_code=200)

        await middleware.dispatch(request, call_next)

        assert captured_user is not None
        assert isinstance(captured_user, UserContext)
        assert captured_user.tenant_id == 'tenant_a'
        assert captured_user.role == 'admin'
        assert captured_user.email == 'admin@tenant_a.com'
        assert captured_user.is_admin == True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
```
  </action>
  <verify>
1. Run pytest tests/test_auth_middleware.py -v to verify tests pass
2. If tests fail due to import issues, adjust the mocking to match actual code structure
3. Verify test coverage includes: spoofing rejection (403), valid request (200), missing auth (401)
  </verify>
  <done>
- test_auth_middleware.py created with comprehensive tests
- Tenant spoofing tests verify 403 response
- Valid request tests verify 200 response
- Public path tests verify bypass behavior
- All tests runnable with pytest
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify tests pass and fix any issues</name>
  <files>tests/test_auth_middleware.py</files>
  <action>
Run the test suite and fix any issues:

```bash
cd C:\Users\jerry\Documents\multitenant-ai-platform-lite
python -m pytest tests/test_auth_middleware.py -v
```

Common issues to fix:
1. Import path issues - adjust sys.path.insert or import statements
2. Mock setup issues - ensure mocks match actual function signatures
3. Async test issues - ensure @pytest.mark.asyncio decorator is present
4. Request/Response construction - Starlette API may differ from mock

If tests fail, analyze the error and fix the test file. The goal is passing tests that verify the security fix from 09-01.

Note: Some tests may need adjustment based on the actual implementation from 09-01. If the middleware doesn't match expected behavior, document the discrepancy.

If pytest-asyncio is not installed:
```bash
pip install pytest-asyncio
```

Add pytest.ini or pyproject.toml config if needed:
```ini
[pytest]
asyncio_mode = auto
```
  </action>
  <verify>
1. pytest tests/test_auth_middleware.py -v shows all tests passing (or skip with clear reason)
2. No import errors or fixture errors
3. At minimum, the tenant spoofing test (test_mismatched_tenant_header_returns_403) passes
  </verify>
  <done>
- All tests pass OR failing tests have documented reason (requires live Supabase, etc.)
- Test infrastructure (pytest-asyncio) is configured
- Tests are runnable in CI environment
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run full test suite:
   ```bash
   python -m pytest tests/test_auth_middleware.py -v --tb=short
   ```

2. Verify test output shows:
   - test_mismatched_tenant_header_returns_403: PASSED
   - test_matching_tenant_header_succeeds: PASSED
   - test_no_tenant_header_uses_user_tenant: PASSED (or documented skip)
   - Other tests: PASSED or documented

3. Verify test file exists and is properly structured:
   - Has docstrings explaining purpose
   - Uses pytest fixtures
   - Tests are isolated (no shared state)
</verification>

<success_criteria>
- [ ] tests/test_auth_middleware.py exists with >100 lines
- [ ] Tests verify tenant spoofing returns 403
- [ ] Tests verify valid requests succeed
- [ ] Tests verify missing auth returns 401
- [ ] pytest runs without import errors
- [ ] Core security tests pass (tenant spoofing rejection)
</success_criteria>

<output>
After completion, create `.planning/phases/09-critical-security/09-03-SUMMARY.md`
</output>
