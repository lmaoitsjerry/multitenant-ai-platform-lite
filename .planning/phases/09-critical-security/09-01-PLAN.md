---
phase: 09-critical-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/middleware/auth_middleware.py
autonomous: true

must_haves:
  truths:
    - "X-Client-ID header is validated against JWT user's actual tenant_id"
    - "Request with mismatched tenant_id (header vs JWT) returns 403 Forbidden"
    - "Request with matching tenant_id proceeds normally"
  artifacts:
    - path: "src/middleware/auth_middleware.py"
      provides: "Tenant validation in auth middleware"
      contains: "tenant_id mismatch"
  key_links:
    - from: "src/middleware/auth_middleware.py"
      to: "UserContext"
      via: "validation before UserContext creation"
      pattern: "X-Client-ID.*tenant_id"
---

<objective>
Validate X-Client-ID header against JWT user's actual tenant_id to prevent tenant spoofing attacks.

Purpose: SEC-02 - A malicious user could send requests with X-Client-ID header set to another tenant, potentially accessing that tenant's data. The middleware currently trusts the header without verifying the user actually belongs to that tenant.

Output: Updated auth_middleware.py that validates header tenant matches JWT user's tenant
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/middleware/auth_middleware.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add X-Client-ID validation in AuthMiddleware</name>
  <files>src/middleware/auth_middleware.py</files>
  <action>
Modify the AuthMiddleware.dispatch() method to validate that the X-Client-ID header matches the user's actual tenant_id from the database.

Current flow (vulnerable):
1. Line 170: `tenant_id = request.headers.get("X-Client-ID") or os.getenv("CLIENT_ID", "africastay")`
2. Line 181-194: JWT is verified
3. Line 197: User is fetched from database using auth_user_id and the header-provided tenant_id
4. Line 210-218: UserContext created with user["tenant_id"]

The vulnerability: If an attacker sends X-Client-ID: "victim_tenant" with their own JWT, the database lookup (line 197) will fail to find them in victim_tenant (because they're not in that tenant), returning 401 "User not found in this organization". This is PARTIALLY safe, BUT there's a logic gap - the config is loaded for the header-provided tenant (line 174) before user validation.

FIX implementation:

1. Keep the initial tenant_id from header (needed for config lookup)
2. After fetching user from database (line 197-208), ADD validation:
   - Compare the header-provided tenant_id with user["tenant_id"]
   - If they differ AND the header was explicitly set (not defaulted), return 403 Forbidden

Add this validation block AFTER the user is fetched and validated (after line 208, before line 210):

```python
# Validate X-Client-ID matches user's actual tenant
header_tenant_id = request.headers.get("X-Client-ID")
if header_tenant_id and header_tenant_id != user["tenant_id"]:
    logger.warning(
        f"Tenant spoofing attempt: header X-Client-ID={header_tenant_id}, "
        f"user tenant_id={user['tenant_id']}, auth_user_id={auth_user_id}"
    )
    return JSONResponse(
        status_code=403,
        content={"detail": "Access denied: tenant mismatch"}
    )
```

This ensures:
- If X-Client-ID header is explicitly provided but doesn't match user's tenant -> 403
- If X-Client-ID header is not provided (uses default) -> falls back to user's tenant
- If X-Client-ID header matches user's tenant -> proceeds normally

Additionally, update line 170 to use user's actual tenant_id for subsequent processing:
After the validation passes, the UserContext on line 211-218 already uses user["tenant_id"] which is correct.
  </action>
  <verify>
Read the modified auth_middleware.py and verify:
1. New validation block exists after user fetch
2. Returns 403 with "tenant mismatch" message when header differs from user's tenant
3. Logs warning for spoofing attempts
4. Existing flow unchanged when header matches or is not provided
  </verify>
  <done>
- X-Client-ID header validation added after user database lookup
- 403 Forbidden returned for tenant mismatch attempts
- Warning logged for security auditing
- Normal requests (matching or no header) work unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config loading to handle tenant mismatch gracefully</name>
  <files>src/middleware/auth_middleware.py</files>
  <action>
Review and ensure the flow handles the case where:
1. Header says tenant_a
2. JWT user belongs to tenant_b
3. Config loaded for tenant_a (which may fail if tenant_a doesn't exist)

Current behavior: get_config(tenant_id) on line 174 could raise FileNotFoundError.

Add defensive logic to also use the user's actual tenant_id for config loading AFTER user validation succeeds. This is a defense-in-depth measure.

After the tenant mismatch validation block from Task 1, ensure the AuthService is re-initialized with the CORRECT tenant config if needed:

```python
# After tenant validation passes, if header was different from user's tenant,
# we already rejected it. If we reach here, header matches or wasn't provided.
# The config is already loaded for the correct tenant.
```

Actually, on closer inspection, the current flow is:
1. Header tenant_id used to load config (line 174)
2. AuthService created with that config's credentials (line 175-178)
3. JWT verified using those credentials (line 181)
4. User fetched from that tenant's database (line 197)

If the header is spoofed to a different tenant:
- Config loads for attacker's chosen tenant (potential info leak of tenant existence)
- AuthService uses that tenant's Supabase credentials
- JWT verification uses that tenant's JWT secret
- If JWT was issued by attacker's real tenant, verification might fail (different secret)
- OR if it's a shared secret, user lookup fails (user not in target tenant)

The fix from Task 1 adds explicit validation. No additional config loading changes needed because:
- If header=tenant_a and user is in tenant_a -> works correctly
- If header=tenant_a and user is in tenant_b -> 403 from Task 1's validation
- If header not provided -> uses default, user must be in default tenant

Document this behavior with a comment explaining the security model.

Add a comment block after line 170 explaining the security validation:

```python
# SECURITY NOTE: The X-Client-ID header is initially trusted to load tenant config.
# After JWT verification and user lookup, we validate that the header matches
# the user's actual tenant_id. This prevents tenant spoofing attacks where an
# attacker sends a valid JWT but targets a different tenant via the header.
```
  </action>
  <verify>
Read auth_middleware.py and verify:
1. Security comment added explaining the validation flow
2. The overall flow is: header -> config -> JWT verify -> user lookup -> TENANT VALIDATION -> proceed
  </verify>
  <done>
- Security documentation added to auth_middleware.py
- Flow clearly shows when tenant validation occurs
- Defense-in-depth approach documented
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Code review: Read src/middleware/auth_middleware.py and verify:
   - Tenant validation block exists after user fetch
   - Returns 403 for mismatch
   - Logs warning for spoofing attempts
   - Security comments explain the flow

2. Static analysis: Verify the validation logic is correct:
   - header_tenant_id extracted from request.headers.get("X-Client-ID")
   - Compared against user["tenant_id"] (not user.tenant_id - it's a dict at this point)
   - Only validates if header was explicitly provided (not None check)
</verification>

<success_criteria>
- [ ] X-Client-ID header is validated against user's actual tenant_id from database
- [ ] Mismatched tenant_id returns 403 Forbidden (not 401, not 500)
- [ ] Warning logged for spoofing attempts with relevant details
- [ ] Normal requests (matching header or no header) work unchanged
- [ ] Security comments document the validation flow
</success_criteria>

<output>
After completion, create `.planning/phases/09-critical-security/09-01-SUMMARY.md`
</output>
