---
phase: 18-code-quality-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/crm_service.py
  - src/api/analytics_routes.py
  - src/api/routes.py
  - src/api/privacy_routes.py
  - src/api/notifications_routes.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Redis caching implemented for pipeline_summary with 60s TTL"
    - "All array access uses bounds checking (len() check or ternary)"
    - "All dict access uses .get() with defaults for optional keys"
  artifacts:
    - path: "src/services/crm_service.py"
      provides: "Redis-cached pipeline summary"
      contains: "redis_client.setex"
    - path: "src/api/privacy_routes.py"
      provides: "Safe array access patterns"
      contains: "if response.data and len(response.data) > 0"
    - path: "src/api/notifications_routes.py"
      provides: "Safe array access"
      contains: "result.data[0] if result.data"
  key_links:
    - from: "src/services/crm_service.py"
      to: "redis"
      via: "get/setex pattern"
      pattern: "redis.*get|redis.*setex"
---

<objective>
Add Redis caching for expensive operations and bounds checking for array/dict access.

Purpose: PROD-14 (Redis caching) improves performance for frequently-accessed data. PROD-16 (bounds checking) prevents crashes on empty results.

Output: CRM service with Redis caching, all array accesses protected with bounds checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PRODUCTION-AUDIT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis caching to CRM service pipeline_summary</name>
  <files>src/services/crm_service.py</files>
  <action>
  Add Redis caching to the `get_pipeline_summary()` method (around line 376-410):

  1. At top of file, add Redis client getter (follow pattern from rate_limiter.py):
     ```python
     import os
     import json

     def get_redis_client():
         """Get Redis client for caching, returns None if unavailable."""
         try:
             import redis
             redis_url = os.getenv("REDIS_URL")
             if redis_url:
                 return redis.from_url(redis_url)
             return None
         except Exception:
             return None
     ```

  2. In get_pipeline_summary() method:
     - At start: Try to get from cache
       ```python
       cache_key = f"crm:pipeline_summary:{self.tenant_id}"
       redis_client = get_redis_client()
       if redis_client:
           try:
               cached = redis_client.get(cache_key)
               if cached:
                   return json.loads(cached)
           except Exception:
               pass  # Continue without cache
       ```
     - At end (before return): Cache the result
       ```python
       if redis_client and result:
           try:
               redis_client.setex(cache_key, 60, json.dumps(result))
           except Exception:
               pass  # Continue without caching
       ```

  3. Also add caching to `get_client_stats()` method (around line 450) with key `crm:client_stats:{tenant_id}` and 60s TTL.

  Important:
  - Use 60 second TTL (matches PROD-14 requirement)
  - Graceful fallback if Redis unavailable (matches existing pattern)
  - Use JSON serialization for complex objects
  </action>
  <verify>
  Run: `python -c "from src.services.crm_service import CRMService; print('Import OK')"`
  Run: `pytest tests/test_crm_service.py -v --tb=short`
  </verify>
  <done>
  - get_pipeline_summary has Redis cache with 60s TTL
  - get_client_stats has Redis cache with 60s TTL
  - Cache miss or Redis failure does not break functionality
  - Cache key includes tenant_id for isolation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add bounds checking to array/dict accesses</name>
  <files>src/api/privacy_routes.py, src/api/notifications_routes.py, src/api/routes.py, src/api/analytics_routes.py</files>
  <action>
  Add bounds checking to all array access patterns identified in PRODUCTION-AUDIT.md:

  1. In privacy_routes.py (lines 406, 461, 474):
     - Line 406: Change `dsar_response.data[0]["id"]` to:
       `dsar_response.data[0]["id"] if dsar_response.data else None`
     - Line 461: Same pattern
     - Line 474: Change `dsar_response.data[0]` to safe access with check
     - Line 629: Ensure `response.data[0]` has bounds check
     - Line 770: Ensure `client.data[0]` has bounds check

  2. In notifications_routes.py (lines 343, 553):
     - Line 343: Already has pattern `result.data[0] if result.data else update_data` - verify
     - Line 553: Already has pattern `result.data[0]['id'] if result.data else None` - verify

  3. In routes.py (lines 1181, 1299):
     - Already have `if data and len(data) > 0: return data[0]` pattern - verify these are correct

  4. In analytics_routes.py (lines 912, 1070):
     - Already have `rows[0] if rows else None` pattern - verify

  5. General pattern to apply:
     ```python
     # Before (unsafe):
     result = response.data[0]

     # After (safe):
     result = response.data[0] if response.data else None
     if not result:
         # Handle missing data appropriately
     ```

  Focus on any remaining unsafe patterns not already fixed.
  </action>
  <verify>
  Run: `grep -n "\[0\]" src/api/privacy_routes.py src/api/notifications_routes.py | grep -v "if.*data"` (should show no unsafe patterns)
  Run: `pytest tests/test_privacy_routes.py tests/test_notifications_routes.py -v --tb=short`
  </verify>
  <done>
  - All [0] accesses have preceding length check or ternary guard
  - No IndexError possible on empty result sets
  - Existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. CRM service imports correctly: `python -c "from src.services.crm_service import CRMService"`
2. Privacy routes compile: `python -m py_compile src/api/privacy_routes.py`
3. Related tests pass: `pytest tests/test_crm_service.py tests/test_privacy_routes.py tests/test_notifications_routes.py -v`
4. No unsafe array access: `grep -rn "\[0\]" src/api/*.py | grep -v "if.*\[0\]" | grep -v "else.*\[0\]" | wc -l` should be minimal
</verification>

<success_criteria>
- PROD-14: Redis caching with 60s TTL on pipeline_summary and client_stats
- PROD-16: All array/dict accesses have bounds checking
- Graceful degradation when Redis unavailable
- No IndexError or KeyError on empty results
</success_criteria>

<output>
After completion, create `.planning/phases/18-code-quality-optimization/18-02-SUMMARY.md`
</output>
