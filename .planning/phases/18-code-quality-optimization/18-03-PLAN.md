---
phase: 18-code-quality-optimization
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified:
  - src/utils/pdf_generator.py
  - src/utils/response_models.py
  - main.py
  - src/api/routes.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PDF generation helper functions extracted to pdf_generator.py"
    - "CORS origins loaded from CORS_ORIGINS environment variable"
    - "Standard APIResponse model exists for consistent responses"
  artifacts:
    - path: "src/utils/pdf_generator.py"
      provides: "Centralized PDF generation"
      contains: "class PDFGenerator"
    - path: "main.py"
      provides: "Environment-based CORS configuration"
      contains: "os.getenv.*CORS_ORIGINS"
    - path: "src/utils/response_models.py"
      provides: "Standard response Pydantic models"
      contains: "class APIResponse"
  key_links:
    - from: "main.py"
      to: "CORS_ORIGINS env var"
      via: "get_cors_origins function"
      pattern: "CORS_ORIGINS"
---

<objective>
Standardize response formats and clean up code duplication.

Purpose: PROD-19 (response standardization), PROD-20 (PDF deduplication), and PROD-24 (CORS env vars) improve code maintainability and consistency.

Output: Standardized response models, deduplicated PDF code, environment-configurable CORS.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PRODUCTION-AUDIT.md
@src/utils/pdf_generator.py
@main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create standard response models</name>
  <files>src/utils/response_models.py</files>
  <action>
  Create a new file with Pydantic response models for API consistency:

  ```python
  """
  Standard Response Models for API endpoints.

  Use these models to ensure consistent response format across all endpoints:
  - success: boolean indicating operation success
  - data: the actual response payload
  - message: optional message for context
  - error: error details when success=False
  """

  from typing import Any, Optional, List, Generic, TypeVar
  from pydantic import BaseModel, Field

  T = TypeVar('T')


  class APIResponse(BaseModel):
      """Standard API response wrapper."""
      success: bool = True
      data: Optional[Any] = None
      message: Optional[str] = None
      error: Optional[str] = None

      class Config:
          json_schema_extra = {
              "example": {
                  "success": True,
                  "data": {"id": 1, "name": "Example"},
                  "message": "Operation completed"
              }
          }


  class PaginatedResponse(BaseModel):
      """Response with pagination metadata."""
      success: bool = True
      data: List[Any] = Field(default_factory=list)
      count: int = 0
      total: int = 0
      page: int = 1
      page_size: int = 20


  class ErrorResponse(BaseModel):
      """Standard error response."""
      success: bool = False
      error: str
      detail: Optional[str] = None
      code: Optional[str] = None


  # Helper function for creating responses
  def success_response(data: Any = None, message: str = None) -> dict:
      """Create a standard success response dict."""
      response = {"success": True}
      if data is not None:
          response["data"] = data
      if message:
          response["message"] = message
      return response


  def error_response(error: str, detail: str = None, code: str = None) -> dict:
      """Create a standard error response dict."""
      response = {"success": False, "error": error}
      if detail:
          response["detail"] = detail
      if code:
          response["code"] = code
      return response
  ```

  This provides:
  - APIResponse: Standard wrapper for all responses
  - PaginatedResponse: For list endpoints with pagination
  - ErrorResponse: For error cases
  - Helper functions for creating response dicts
  </action>
  <verify>
  Run: `python -c "from src.utils.response_models import APIResponse, success_response, error_response; print('Models OK')"`
  Run: `python -m py_compile src/utils/response_models.py`
  </verify>
  <done>
  - APIResponse model created with success/data/message/error fields
  - PaginatedResponse model for list endpoints
  - Helper functions success_response() and error_response()
  - File compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify CORS environment configuration and document PDF structure</name>
  <files>main.py, src/utils/pdf_generator.py</files>
  <action>
  1. Verify CORS environment configuration in main.py (already implemented):
     - Line 107-136: `get_cors_origins()` already reads from `CORS_ORIGINS` env var
     - Verify the pattern: `os.getenv("CORS_ORIGINS", "")`
     - Ensure comma-separated parsing works: `[origin.strip() for origin in env_origins.split(",")]`
     - Document expected format in code comment

  2. Add docstring to get_cors_origins() function explaining:
     - Environment variable format: `CORS_ORIGINS=https://app.example.com,https://admin.example.com`
     - Default origins for development
     - Production recommendation

  3. In pdf_generator.py, verify the PDFGenerator class is centralized:
     - The class already handles both quote and invoice PDF generation
     - Add a module docstring noting this is the single source for PDF generation
     - Verify both `generate_quote_pdf()` and `generate_invoice_pdf()` methods exist

  4. Check routes.py for any inline PDF generation code that should use PDFGenerator:
     - Search for WeasyPrint or fpdf usage outside pdf_generator.py
     - If found, update to use PDFGenerator class

  The CORS configuration (PROD-24) is already implemented - this task verifies and documents it.
  The PDF generator (PROD-20) already exists as a centralized class - verify no duplication exists.
  </action>
  <verify>
  Run: `grep -n "CORS_ORIGINS" main.py` (should show env var usage)
  Run: `grep -rn "from weasyprint\|from fpdf" src/ | grep -v pdf_generator` (should be empty or minimal)
  Run: `python -c "from src.utils.pdf_generator import PDFGenerator; print('PDFGenerator OK')"`
  </verify>
  <done>
  - CORS_ORIGINS env var documented with format example
  - get_cors_origins() has comprehensive docstring
  - PDFGenerator is confirmed as single PDF generation source
  - No duplicate PDF code outside pdf_generator.py
  </done>
</task>

</tasks>

<verification>
1. Response models import correctly: `python -c "from src.utils.response_models import *"`
2. Main.py still starts: `python -c "import main; print('Main OK')"`
3. CORS env var works: `CORS_ORIGINS="https://test.com" python -c "import main; print(main.get_cors_origins())"`
4. All tests pass: `pytest tests/ -v --tb=short -x`
</verification>

<success_criteria>
- PROD-19: Standard response models created (APIResponse, PaginatedResponse, ErrorResponse)
- PROD-20: PDFGenerator confirmed as centralized class (no duplicate PDF code)
- PROD-24: CORS_ORIGINS environment variable already configured and documented
- Helper functions available for consistent response creation
</success_criteria>

<output>
After completion, create `.planning/phases/18-code-quality-optimization/18-03-SUMMARY.md`
</output>
