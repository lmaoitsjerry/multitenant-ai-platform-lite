---
phase: 03-quote-generation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/quote_agent.py
  - src/webhooks/email_webhook.py
  - tests/test_quote_generation.py
autonomous: true

must_haves:
  truths:
    - "Email with travel inquiry triggers quote generation"
    - "Quote record contains correct destination, dates, travelers from parsed email"
    - "Hotels queried for the destination"
    - "Pricing calculated from tenant's rate table"
    - "Quote saved to database with status 'draft'"
  artifacts:
    - path: "src/agents/quote_agent.py"
      provides: "Quote generation with draft status option"
      contains: "status.*draft"
    - path: "src/webhooks/email_webhook.py"
      provides: "Quote generation call from email webhook"
      contains: "generate_quote"
    - path: "tests/test_quote_generation.py"
      provides: "Test coverage for quote generation flow"
      min_lines: 50
  key_links:
    - from: "src/webhooks/email_webhook.py"
      to: "src/agents/quote_agent.py"
      via: "QuoteAgent.generate_quote(customer_data)"
      pattern: "quote_agent\\.generate_quote"
    - from: "src/agents/quote_agent.py"
      to: "src/tools/bigquery_tool.py"
      via: "BigQueryTool.find_matching_hotels"
      pattern: "bq_tool\\.find_matching_hotels"
    - from: "src/agents/quote_agent.py"
      to: "supabase.quotes"
      via: "_save_quote_to_supabase"
      pattern: "table\\('quotes'\\)"
---

<objective>
Connect parsed email data to quote generation pipeline, ensuring quotes are created with correct details and saved with "draft" status for consultant review before sending.

Purpose: Complete the email-to-quote automation by wiring the LLM-parsed trip details into the existing QuoteAgent, with proper status handling for the draft-review-send workflow.

Output: Working pipeline where inbound travel inquiry emails result in draft quotes ready for consultant review.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context - email parsing ready
@.planning/phases/02-tenant-lookup-email-parsing/02-02-SUMMARY.md

# Key source files
@src/agents/quote_agent.py
@src/webhooks/email_webhook.py
@src/agents/llm_email_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add draft status support to QuoteAgent</name>
  <files>src/agents/quote_agent.py</files>
  <action>
Modify QuoteAgent.generate_quote() to support generating quotes with "draft" status:

1. Add `initial_status` parameter to generate_quote() method signature:
   ```python
   def generate_quote(
       self,
       customer_data: Dict[str, Any],
       send_email: bool = True,
       assign_consultant: bool = True,
       selected_hotels: Optional[List[str]] = None,
       initial_status: str = "generated"  # NEW: 'draft' or 'generated'
   ) -> Dict[str, Any]:
   ```

2. Use initial_status when building quote object (around line 168):
   - If initial_status='draft', set status='draft' regardless of email sending
   - If initial_status='generated' (default), keep existing behavior

3. Skip email sending and follow-up call scheduling when status is 'draft':
   - Check `initial_status == 'draft'` before email sending section
   - Only send email and schedule calls when initial_status != 'draft'

4. Update quote status logic (around line 199):
   ```python
   if initial_status == 'draft':
       quote['status'] = 'draft'
   else:
       quote['email_sent'] = email_sent
       quote['status'] = 'sent' if email_sent else 'generated'
   ```

5. Add docstring note about draft workflow:
   "Use initial_status='draft' for email auto-quotes that require consultant review before sending."

Preserve all existing behavior for non-draft quotes - this is additive change only.
  </action>
  <verify>
Run: `grep -n "initial_status" src/agents/quote_agent.py`
Should show parameter in generate_quote() and usage in status logic.

Run: `grep -n "draft" src/agents/quote_agent.py`
Should show draft status handling.
  </verify>
  <done>
QuoteAgent.generate_quote() accepts initial_status parameter and correctly creates quotes with "draft" status when specified, skipping email sending for drafts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire email webhook to create draft quotes</name>
  <files>src/webhooks/email_webhook.py</files>
  <action>
Modify process_inbound_email() to create draft quotes for auto-generated quotes from inbound emails:

1. Locate the quote generation call in process_inbound_email() (around line 659):
   ```python
   result = quote_agent.generate_quote(
       customer_data=parsed_data,
       send_email=True,       # CHANGE to False
       assign_consultant=True,
       initial_status='draft'  # ADD this parameter
   )
   ```

2. Update diagnostic logging for STEP 11 to reflect draft status:
   ```python
   diagnostic_log(diagnostic_id, 11, "Draft quote generated for consultant review", {
       'quote_id': quote_id,
       'status': 'draft',
       'customer_email': email.from_email,
       'destination': parsed_data.get('destination'),
       'elapsed_ms': round(elapsed * 1000, 2)
   })
   ```

3. Update the notification to indicate draft (around line 676-685):
   Change notification message to indicate quote needs review before sending.

Rationale: Auto-generated quotes from emails should be reviewed by consultants before sending to customers. This prevents incorrect quotes from being automatically sent.
  </action>
  <verify>
Run: `grep -n "initial_status.*draft" src/webhooks/email_webhook.py`
Should show draft parameter in generate_quote call.

Run: `grep -n "send_email.*False" src/webhooks/email_webhook.py`
Should show email sending disabled for auto-quotes.
  </verify>
  <done>
Email webhook creates draft quotes that are saved to database but not automatically sent, allowing consultant review first.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for quote generation flow</name>
  <files>tests/test_quote_generation.py</files>
  <action>
Create comprehensive tests for the email-to-quote flow:

```python
"""
Tests for Quote Generation Pipeline

Verifies:
1. Parsed email data flows correctly to QuoteAgent
2. Draft quotes created with correct status
3. Hotels queried for destination
4. Quote saved to database
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime

from src.agents.quote_agent import QuoteAgent
from config.loader import ClientConfig


class TestQuoteGenerationPipeline:
    """Test email -> quote generation flow"""

    @pytest.fixture
    def mock_config(self):
        """Create mock client config"""
        config = Mock(spec=ClientConfig)
        config.client_id = 'test_tenant'
        config.destination_names = ['Zanzibar', 'Mauritius', 'Seychelles']
        config.timezone = 'Africa/Johannesburg'
        return config

    @pytest.fixture
    def parsed_email_data(self):
        """Sample parsed email data from LLMEmailParser"""
        return {
            'name': 'John Doe',
            'email': 'john@example.com',
            'destination': 'Zanzibar',
            'check_in': '2025-06-15',
            'check_out': '2025-06-22',
            'adults': 2,
            'children': 0,
            'children_ages': [],
            'budget': 50000,
            'is_travel_inquiry': True,
            'parse_method': 'llm'
        }

    def test_draft_quote_created_with_correct_status(self, mock_config, parsed_email_data):
        """Verify draft quotes have status='draft'"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            # Mock hotel finding
            agent.bq_tool.find_matching_hotels.return_value = [{
                'hotel_name': 'Test Hotel',
                'rate_id': 'rate_123',
                'hotel_rating': '4*',
                'room_type': 'Deluxe',
                'meal_plan': 'BB'
            }]

            # Mock pricing
            agent.bq_tool.calculate_quote_price.return_value = {
                'per_person_rates': {'adult_sharing': 5000},
                'totals': {'grand_total': 10000}
            }

            # Mock consultant
            agent.bq_tool.get_next_consultant_round_robin.return_value = {
                'consultant_id': 'consultant_1'
            }

            result = agent.generate_quote(
                customer_data=parsed_email_data,
                send_email=False,
                initial_status='draft'
            )

            assert result['success'] == True
            assert result['quote']['status'] == 'draft'
            assert result['email_sent'] == False

    def test_destination_passed_to_hotel_query(self, mock_config, parsed_email_data):
        """Verify destination from parsed email used in hotel query"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            agent.bq_tool.find_matching_hotels.return_value = []

            result = agent.generate_quote(
                customer_data=parsed_email_data,
                send_email=False,
                initial_status='draft'
            )

            # Verify destination was passed to hotel query
            call_args = agent.bq_tool.find_matching_hotels.call_args
            assert call_args[1]['destination'] == 'Zanzibar'

    def test_quote_contains_customer_details(self, mock_config, parsed_email_data):
        """Verify quote contains all customer details from parsed email"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            agent.bq_tool.find_matching_hotels.return_value = [{
                'hotel_name': 'Test Hotel',
                'rate_id': 'rate_123'
            }]
            agent.bq_tool.calculate_quote_price.return_value = {
                'per_person_rates': {'adult_sharing': 5000},
                'totals': {'grand_total': 10000}
            }
            agent.bq_tool.get_next_consultant_round_robin.return_value = None

            result = agent.generate_quote(
                customer_data=parsed_email_data,
                send_email=False,
                initial_status='draft'
            )

            quote = result['quote']
            assert quote['customer_name'] == 'John Doe'
            assert quote['customer_email'] == 'john@example.com'
            assert quote['destination'] == 'Zanzibar'
            assert quote['check_in_date'] == '2025-06-15'
            assert quote['check_out_date'] == '2025-06-22'
            assert quote['adults'] == 2
            assert quote['children'] == 0

    def test_no_email_sent_for_draft(self, mock_config, parsed_email_data):
        """Verify no email is sent when creating draft quote"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            agent.bq_tool.find_matching_hotels.return_value = [{
                'hotel_name': 'Test Hotel',
                'rate_id': 'rate_123'
            }]
            agent.bq_tool.calculate_quote_price.return_value = {
                'per_person_rates': {'adult_sharing': 5000},
                'totals': {'grand_total': 10000}
            }
            agent.bq_tool.get_next_consultant_round_robin.return_value = None

            result = agent.generate_quote(
                customer_data=parsed_email_data,
                send_email=True,  # Even with True, draft should not send
                initial_status='draft'
            )

            agent.email_sender.send_quote_email.assert_not_called()

    def test_quote_saved_to_supabase(self, mock_config, parsed_email_data):
        """Verify quote is saved to Supabase"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.supabase.client = Mock()
            agent.supabase.client.table.return_value.insert.return_value.execute.return_value = Mock(data=[{}])
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            agent.bq_tool.find_matching_hotels.return_value = [{
                'hotel_name': 'Test Hotel',
                'rate_id': 'rate_123'
            }]
            agent.bq_tool.calculate_quote_price.return_value = {
                'per_person_rates': {'adult_sharing': 5000},
                'totals': {'grand_total': 10000}
            }
            agent.bq_tool.get_next_consultant_round_robin.return_value = None

            result = agent.generate_quote(
                customer_data=parsed_email_data,
                send_email=False,
                initial_status='draft'
            )

            # Verify Supabase insert was called
            agent.supabase.client.table.assert_called_with('quotes')


class TestQuoteAgentBackwardCompatibility:
    """Ensure existing behavior is preserved"""

    @pytest.fixture
    def mock_config(self):
        config = Mock(spec=ClientConfig)
        config.client_id = 'test_tenant'
        config.destination_names = ['Zanzibar']
        config.timezone = 'UTC'
        return config

    def test_default_status_is_generated(self, mock_config):
        """Verify default behavior (no initial_status) still works"""
        with patch.object(QuoteAgent, '__init__', return_value=None):
            agent = QuoteAgent.__new__(QuoteAgent)
            agent.config = mock_config
            agent.db = Mock()
            agent.bq_tool = Mock()
            agent.pdf_generator = Mock()
            agent.email_sender = Mock()
            agent.supabase = Mock()
            agent.crm = Mock()
            agent.max_hotels_per_quote = 3
            agent.default_nights = 7

            agent.bq_tool.find_matching_hotels.return_value = []

            result = agent.generate_quote(
                customer_data={'email': 'test@test.com', 'destination': 'Zanzibar'},
                send_email=False
                # No initial_status = should default to 'generated'
            )

            # With no hotels found, returns no_availability
            assert result['status'] == 'no_availability'
```

This test file should be placed at tests/test_quote_generation.py.
  </action>
  <verify>
Run: `python -m pytest tests/test_quote_generation.py -v`
All tests should pass.

Run: `wc -l tests/test_quote_generation.py`
Should show at least 200 lines.
  </verify>
  <done>
Comprehensive test suite validates: draft status creation, email not sent for drafts, customer details preserved, destination passed to hotel query, backward compatibility maintained.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Unit tests pass:**
   ```bash
   python -m pytest tests/test_quote_generation.py -v
   ```

2. **Draft status in QuoteAgent:**
   ```bash
   grep -n "initial_status" src/agents/quote_agent.py | head -5
   ```
   Should show parameter and usage.

3. **Webhook uses draft:**
   ```bash
   grep -n "draft" src/webhooks/email_webhook.py
   ```
   Should show initial_status='draft' in generate_quote call.

4. **Existing tests still pass:**
   ```bash
   python -m pytest tests/test_email_parser.py -v
   ```
   Should show all 16 parser tests pass.

5. **Manual verification (optional):**
   Use the test endpoint to verify full flow:
   ```bash
   curl "http://localhost:8000/webhooks/email/test/africastay?email=test@example.com&subject=Zanzibar%20quote"
   ```
   Check logs for STEP 11 showing "draft" status.
</verification>

<success_criteria>
Phase 3 is complete when:
- [ ] QuoteAgent.generate_quote() accepts initial_status parameter
- [ ] initial_status='draft' creates quotes with status='draft'
- [ ] Draft quotes skip email sending and call scheduling
- [ ] Email webhook calls generate_quote with initial_status='draft'
- [ ] All tests pass (new + existing)
- [ ] Existing quote generation behavior unchanged for non-draft quotes
</success_criteria>

<output>
After completion, create `.planning/phases/03-quote-generation-pipeline/03-01-SUMMARY.md`
</output>
