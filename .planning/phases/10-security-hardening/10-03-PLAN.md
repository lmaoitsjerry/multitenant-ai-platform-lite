---
phase: 10-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - src/middleware/rate_limiter.py
  - docs/REDIS_SETUP.md
autonomous: true

must_haves:
  truths:
    - "redis-py is available as a dependency"
    - "Rate limiting works with Redis when REDIS_URL is set"
    - "Rate limiting falls back to in-memory when Redis unavailable"
    - "Documentation explains Cloud Run Redis options"
  artifacts:
    - path: "requirements.txt"
      provides: "Redis dependency"
      contains: "redis"
    - path: "src/middleware/rate_limiter.py"
      provides: "Redis-backed rate limiting"
      contains: "RedisRateLimitStore"
    - path: "docs/REDIS_SETUP.md"
      provides: "Redis setup documentation"
      contains: "Cloud Run"
  key_links:
    - from: "src/middleware/rate_limiter.py"
      to: "redis"
      via: "import"
      pattern: "import redis"
---

<objective>
Enable Redis-backed rate limiting for multi-instance deployments on Cloud Run.

Purpose: In-memory rate limiting doesn't work when you have multiple Cloud Run instances because each instance has its own memory. Redis provides shared state so rate limits work correctly across all instances. The existing code already has RedisRateLimitStore - we just need to add the dependency and document setup.

Output: redis-py dependency added, rate limiter enhanced for production use, and documentation for Cloud Run Redis setup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/middleware/rate_limiter.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add redis-py dependency to requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add redis-py to requirements.txt in the Rate Limiting section (around line 74-75).

Update the Rate Limiting section to:
```
# Rate Limiting
slowapi>=0.1.9
redis>=5.0.0
```

Use redis>=5.0.0 which is the current stable version with good async support.
  </action>
  <verify>
    - `grep "^redis" requirements.txt` shows "redis>=5.0.0"
    - `pip install redis --dry-run` shows the package would be installed
  </verify>
  <done>redis-py added to requirements.txt</done>
</task>

<task type="auto">
  <name>Task 2: Enhance rate limiter with connection health check and logging</name>
  <files>src/middleware/rate_limiter.py</files>
  <action>
The rate_limiter.py already has RedisRateLimitStore implemented. Enhance it with:

1. Add health check method to RedisRateLimitStore:
```python
def is_healthy(self) -> bool:
    """Check if Redis connection is healthy."""
    if not self._redis:
        return False
    try:
        self._redis.ping()
        return True
    except Exception:
        return False
```

2. Add logging when Redis connects or falls back:
- In __init__, add more detailed logging for connection status
- Log the Redis URL (without password) when connecting

3. Add a helper function to get store status:
```python
def get_rate_limit_store_info() -> dict:
    """Get information about the current rate limit store."""
    store = get_store()
    is_redis = isinstance(store, RedisRateLimitStore)
    return {
        "backend": "redis" if is_redis and store.is_healthy() else "memory",
        "redis_connected": is_redis and store.is_healthy() if is_redis else False,
        "message": "Redis rate limiting active" if (is_redis and store.is_healthy()) else "In-memory rate limiting (single instance only)"
    }
```

4. Update the RedisRateLimitStore to mask password in logs:
```python
# In __init__:
# Log connection (mask password)
safe_url = redis_url.split('@')[-1] if '@' in redis_url else redis_url
logger.info(f"Connecting to Redis at {safe_url}")
```

These enhancements make the rate limiter production-ready with proper observability.
  </action>
  <verify>
    - `grep "is_healthy" src/middleware/rate_limiter.py` returns matches
    - `grep "get_rate_limit_store_info" src/middleware/rate_limiter.py` returns matches
    - `python -c "from src.middleware.rate_limiter import get_rate_limit_store_info; print(get_rate_limit_store_info())"` works
  </verify>
  <done>Rate limiter enhanced with health checks and observability</done>
</task>

<task type="auto">
  <name>Task 3: Create Redis setup documentation for Cloud Run</name>
  <files>docs/REDIS_SETUP.md</files>
  <action>
Create documentation explaining how to set up Redis for Cloud Run deployments.

Content:
```markdown
# Redis Setup for Rate Limiting

This document explains how to configure Redis for production rate limiting on Cloud Run.

## Why Redis?

The rate limiter uses in-memory storage by default, which works for single-instance deployments.
For production with multiple Cloud Run instances, Redis provides shared state so rate limits
work correctly across all instances.

## Options

### Option 1: Google Cloud Memorystore (Recommended for GCP)

[Google Cloud Memorystore for Redis](https://cloud.google.com/memorystore/docs/redis) provides
a fully managed Redis service.

**Setup:**
1. Create a Memorystore instance in the same region as Cloud Run
2. Configure VPC connector for Cloud Run to access Memorystore
3. Set REDIS_URL environment variable

```bash
# Create Memorystore instance
gcloud redis instances create zorah-rate-limit \
  --size=1 \
  --region=us-central1 \
  --redis-version=redis_7_0

# Get the IP address
gcloud redis instances describe zorah-rate-limit --region=us-central1 --format="value(host)"

# Set in Cloud Run
gcloud run services update zorah-api \
  --set-env-vars="REDIS_URL=redis://10.x.x.x:6379"
```

**Cost:** ~$35/month for basic tier (1GB)

### Option 2: Upstash (Serverless Redis)

[Upstash](https://upstash.com/) provides serverless Redis with pay-per-request pricing.
No VPC configuration needed - uses HTTPS.

**Setup:**
1. Create account at upstash.com
2. Create a Redis database
3. Copy the connection string
4. Set REDIS_URL in Cloud Run

```bash
gcloud run services update zorah-api \
  --set-env-vars="REDIS_URL=rediss://default:xxx@xxx.upstash.io:6379"
```

**Cost:** Free tier available (10K commands/day), then $0.2/100K commands

### Option 3: Redis Cloud

[Redis Cloud](https://redis.com/cloud/overview/) by Redis Labs offers managed Redis.

**Setup:** Similar to Upstash - create database, get connection string, set env var.

**Cost:** Free tier (30MB), paid plans from $5/month

## Configuration

Set the `REDIS_URL` environment variable in your Cloud Run service:

```bash
# Format: redis://[username:password@]host:port[/db]
REDIS_URL=redis://10.0.0.5:6379
REDIS_URL=rediss://user:pass@host:6379  # TLS (note: rediss with double s)
```

## Verifying Redis Connection

Check the `/health` endpoint or logs for rate limiter status:

```json
{
  "backend": "redis",
  "redis_connected": true,
  "message": "Redis rate limiting active"
}
```

If Redis is not available, the system automatically falls back to in-memory rate limiting
with a warning in logs.

## Fallback Behavior

If Redis is unavailable:
1. Rate limiter falls back to in-memory storage
2. Warning logged: "Redis not available, falling back to in-memory"
3. Rate limits work but only per-instance (not shared across instances)

This means the system degrades gracefully - API remains functional, just with
potentially higher effective rate limits during Redis outages.

## Testing Locally

```bash
# Start Redis locally
docker run -d -p 6379:6379 redis:7

# Set environment variable
export REDIS_URL=redis://localhost:6379

# Run the application
python main.py
# Should see: "Connected to Redis for rate limiting"
```
```
  </action>
  <verify>
    - File exists at docs/REDIS_SETUP.md
    - Contains sections for Memorystore, Upstash, and Redis Cloud
    - Contains environment variable instructions
  </verify>
  <done>Redis setup documentation created for Cloud Run</done>
</task>

</tasks>

<verification>
Run the following checks after all tasks complete:

1. **Verify dependency added:**
   ```bash
   grep "^redis" requirements.txt
   # Expected: redis>=5.0.0
   ```

2. **Verify rate limiter imports work:**
   ```bash
   python -c "from src.middleware.rate_limiter import get_rate_limit_store_info, RateLimiter; print(get_rate_limit_store_info())"
   # Expected: {'backend': 'memory', 'redis_connected': False, 'message': 'In-memory rate limiting...'}
   ```

3. **Verify documentation exists:**
   ```bash
   ls -la docs/REDIS_SETUP.md
   ```

4. **Run existing tests:**
   ```bash
   pytest tests/ -v --tb=short -k "not integration"
   # Existing tests should pass
   ```
</verification>

<success_criteria>
- [ ] redis>=5.0.0 added to requirements.txt
- [ ] Rate limiter has is_healthy() method
- [ ] Rate limiter has get_rate_limit_store_info() function
- [ ] Password masked in Redis connection logs
- [ ] docs/REDIS_SETUP.md created with Cloud Run options
- [ ] Fallback behavior documented
- [ ] Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-hardening/10-03-SUMMARY.md`
</output>
