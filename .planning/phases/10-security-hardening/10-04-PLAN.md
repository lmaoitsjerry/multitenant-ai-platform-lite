---
phase: 10-security-hardening
plan: 04
type: tdd
wave: 2
depends_on:
  - "10-03"
files_modified:
  - tests/test_rate_limiter.py
autonomous: true

must_haves:
  truths:
    - "Unit tests verify rate limiting enforces limits correctly"
    - "Tests cover both in-memory and Redis backends"
    - "Tests verify fallback behavior when Redis unavailable"
    - "Tests pass in CI without requiring Redis"
  artifacts:
    - path: "tests/test_rate_limiter.py"
      provides: "Rate limiting unit tests"
      min_lines: 100
  key_links:
    - from: "tests/test_rate_limiter.py"
      to: "src/middleware/rate_limiter.py"
      via: "import"
      pattern: "from src.middleware.rate_limiter import"
---

<objective>
Create unit tests for rate limiting behavior to ensure limits are enforced correctly.

Purpose: Rate limiting is a critical security control. Tests verify that limits are enforced, that the Redis and in-memory backends work correctly, and that the system degrades gracefully when Redis is unavailable.

Output: Comprehensive test suite for rate limiting with tests for both backends.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/middleware/rate_limiter.py
@tests/test_auth_middleware.py
</context>

<feature>
  <name>Rate Limiting Unit Tests</name>
  <files>tests/test_rate_limiter.py</files>
  <behavior>
Tests for the rate limiting system covering:

1. **InMemoryRateLimitStore tests:**
   - increment() increases count and returns new count
   - get_count() returns current count
   - counts reset after window expires
   - expired entries are cleaned up

2. **RateLimiter tests:**
   - is_allowed() returns True when under limit
   - is_allowed() returns False when over limit
   - check_rate_limit() returns correct tuple (allowed, current, limit, reset)
   - Different endpoints can have different limits

3. **RateLimitMiddleware tests:**
   - Returns 429 when rate limit exceeded
   - Returns rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining)
   - Skips rate limiting for health endpoints
   - Uses tenant ID from X-Client-ID header

4. **Fallback behavior tests:**
   - RedisRateLimitStore falls back to memory when Redis unavailable
   - get_rate_limit_store_info() returns correct backend info

5. **Configuration tests:**
   - RateLimitConfig.get_limit() returns correct limits for known paths
   - RateLimitConfig.get_limit() returns default for unknown paths
  </behavior>
  <implementation>
Use pytest with pytest-asyncio for async middleware tests.
Mock Redis connection for Redis-related tests to avoid requiring Redis in CI.
Use time.sleep() or mock time for expiry tests.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter test file with store tests</name>
  <files>tests/test_rate_limiter.py</files>
  <action>
Create the test file with tests for InMemoryRateLimitStore and RateLimitConfig.

```python
"""
Unit tests for Rate Limiting

Tests cover:
- InMemoryRateLimitStore behavior
- RateLimiter logic
- RateLimitMiddleware integration
- Configuration defaults and overrides
"""

import pytest
import time
from unittest.mock import Mock, patch, MagicMock
from fastapi import FastAPI, Request
from fastapi.testclient import TestClient

from src.middleware.rate_limiter import (
    InMemoryRateLimitStore,
    RedisRateLimitStore,
    RateLimiter,
    RateLimitMiddleware,
    RateLimitConfig,
    get_store,
    get_rate_limit_store_info,
)


# ==================== InMemoryRateLimitStore Tests ====================

class TestInMemoryRateLimitStore:
    """Tests for in-memory rate limit storage."""

    def test_increment_returns_count(self):
        """Increment should return the new count."""
        store = InMemoryRateLimitStore()

        count1 = store.increment("test_key", 60)
        count2 = store.increment("test_key", 60)
        count3 = store.increment("test_key", 60)

        assert count1 == 1
        assert count2 == 2
        assert count3 == 3

    def test_get_count_returns_current(self):
        """Get count should return current value."""
        store = InMemoryRateLimitStore()

        store.increment("test_key", 60)
        store.increment("test_key", 60)

        assert store.get_count("test_key") == 2

    def test_get_count_returns_zero_for_unknown(self):
        """Get count should return 0 for unknown keys."""
        store = InMemoryRateLimitStore()

        assert store.get_count("unknown_key") == 0

    def test_reset_clears_count(self):
        """Reset should clear the count for a key."""
        store = InMemoryRateLimitStore()

        store.increment("test_key", 60)
        store.increment("test_key", 60)
        store.reset("test_key")

        assert store.get_count("test_key") == 0

    def test_expired_entries_cleaned(self):
        """Expired entries should be cleaned up."""
        store = InMemoryRateLimitStore()

        # Set a very short window (1 second)
        store.increment("test_key", 1)
        assert store.get_count("test_key") == 1

        # Wait for expiry
        time.sleep(1.1)

        # Should be cleaned up on next access
        assert store.get_count("test_key") == 0

    def test_different_keys_independent(self):
        """Different keys should have independent counts."""
        store = InMemoryRateLimitStore()

        store.increment("key_a", 60)
        store.increment("key_a", 60)
        store.increment("key_b", 60)

        assert store.get_count("key_a") == 2
        assert store.get_count("key_b") == 1


# ==================== RateLimitConfig Tests ====================

class TestRateLimitConfig:
    """Tests for rate limit configuration."""

    def test_get_limit_exact_match(self):
        """Should return exact match limit."""
        requests, window = RateLimitConfig.get_limit('/api/v1/quotes/generate')

        assert requests == 200
        assert window == 3600

    def test_get_limit_default_for_unknown(self):
        """Should return default for unknown paths."""
        requests, window = RateLimitConfig.get_limit('/api/v1/unknown/endpoint')

        assert requests == RateLimitConfig.DEFAULT_REQUESTS_PER_MINUTE
        assert window == 60

    def test_get_daily_limit(self):
        """Should return daily limits for resource types."""
        assert RateLimitConfig.get_daily_limit('quotes') == 1000
        assert RateLimitConfig.get_daily_limit('emails') == 1500
        assert RateLimitConfig.get_daily_limit('unknown') == 1000  # default


# ==================== RateLimiter Tests ====================

class TestRateLimiter:
    """Tests for RateLimiter logic."""

    def test_is_allowed_under_limit(self):
        """Should return True when under limit."""
        store = InMemoryRateLimitStore()
        limiter = RateLimiter(store=store)

        # Should be allowed (under limit of 10)
        assert limiter.is_allowed("tenant_1", "/api/test", 10, 60) is True

    def test_is_allowed_at_limit(self):
        """Should return True at exactly the limit."""
        store = InMemoryRateLimitStore()
        limiter = RateLimiter(store=store)

        # Make 10 requests (limit is 10)
        for _ in range(10):
            limiter.is_allowed("tenant_1", "/api/test", 10, 60)

        # 10th request should still be allowed
        # (we're at the limit, not over)
        # Actually, increment happens before check, so 10th call = count 10 = at limit = allowed
        # 11th call = count 11 = over limit = not allowed

    def test_is_allowed_over_limit(self):
        """Should return False when over limit."""
        store = InMemoryRateLimitStore()
        limiter = RateLimiter(store=store)

        # Make 11 requests (limit is 10)
        for _ in range(11):
            limiter.is_allowed("tenant_1", "/api/test", 10, 60)

        # 12th request should be denied
        assert limiter.is_allowed("tenant_1", "/api/test", 10, 60) is False

    def test_check_rate_limit_returns_tuple(self):
        """check_rate_limit should return correct tuple."""
        store = InMemoryRateLimitStore()
        limiter = RateLimiter(store=store)

        allowed, current, limit, reset = limiter.check_rate_limit(
            "tenant_1", "/api/test", 100, 60
        )

        assert allowed is True
        assert current == 1
        assert limit == 100
        assert reset == 60

    def test_different_tenants_independent(self):
        """Different tenants should have independent limits."""
        store = InMemoryRateLimitStore()
        limiter = RateLimiter(store=store)

        # Exhaust tenant_1's limit
        for _ in range(11):
            limiter.is_allowed("tenant_1", "/api/test", 10, 60)

        # tenant_2 should still be allowed
        assert limiter.is_allowed("tenant_2", "/api/test", 10, 60) is True

        # tenant_1 should be denied
        assert limiter.is_allowed("tenant_1", "/api/test", 10, 60) is False


# ==================== RateLimitMiddleware Tests ====================

class TestRateLimitMiddleware:
    """Tests for rate limit middleware integration."""

    @pytest.fixture
    def app_with_middleware(self):
        """Create a test app with rate limiting middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitMiddleware)

        @app.get("/api/test")
        def test_endpoint():
            return {"status": "ok"}

        @app.get("/health")
        def health_endpoint():
            return {"status": "healthy"}

        return app

    def test_returns_rate_limit_headers(self, app_with_middleware):
        """Response should include rate limit headers."""
        client = TestClient(app_with_middleware)

        response = client.get("/api/test", headers={"X-Client-ID": "test_tenant"})

        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers
        assert "X-RateLimit-Reset" in response.headers

    def test_skips_health_endpoint(self, app_with_middleware):
        """Should not rate limit health endpoints."""
        client = TestClient(app_with_middleware)

        # Make many requests to health endpoint
        for _ in range(100):
            response = client.get("/health")
            assert response.status_code == 200

    def test_uses_client_id_header(self, app_with_middleware):
        """Should use X-Client-ID for tenant identification."""
        client = TestClient(app_with_middleware)

        # Different tenants should have independent limits
        response1 = client.get("/api/test", headers={"X-Client-ID": "tenant_a"})
        response2 = client.get("/api/test", headers={"X-Client-ID": "tenant_b"})

        # Both should succeed (independent limits)
        assert response1.status_code == 200
        assert response2.status_code == 200


# ==================== Store Info Tests ====================

class TestStoreInfo:
    """Tests for rate limit store information."""

    def test_get_store_info_memory(self):
        """Should return memory backend info when Redis not configured."""
        # Clear any cached store
        import src.middleware.rate_limiter as rl
        rl._store = None

        with patch.dict('os.environ', {}, clear=True):
            info = get_rate_limit_store_info()

        assert info["backend"] == "memory"
        assert info["redis_connected"] is False


# ==================== Redis Fallback Tests ====================

class TestRedisFallback:
    """Tests for Redis fallback behavior."""

    def test_falls_back_when_redis_unavailable(self):
        """Should fall back to memory when Redis connection fails."""
        with patch('redis.from_url') as mock_redis:
            mock_redis.side_effect = Exception("Connection refused")

            store = RedisRateLimitStore("redis://invalid:6379")

            # Should use fallback
            assert store._redis is None

            # Should still work (using fallback)
            count = store.increment("test_key", 60)
            assert count == 1

    def test_is_healthy_returns_false_when_no_redis(self):
        """is_healthy should return False when Redis not connected."""
        with patch('redis.from_url') as mock_redis:
            mock_redis.side_effect = Exception("Connection refused")

            store = RedisRateLimitStore("redis://invalid:6379")

            assert store.is_healthy() is False
```

This creates a comprehensive test suite covering:
- InMemoryRateLimitStore (6 tests)
- RateLimitConfig (3 tests)
- RateLimiter (5 tests)
- RateLimitMiddleware (3 tests)
- Store info (1 test)
- Redis fallback (2 tests)

Total: ~20 tests
  </action>
  <verify>
    - File exists at tests/test_rate_limiter.py
    - `pytest tests/test_rate_limiter.py -v --collect-only` shows all tests discovered
    - `pytest tests/test_rate_limiter.py -v` all tests pass
  </verify>
  <done>Rate limiter unit tests created with 20+ tests covering all components</done>
</task>

</tasks>

<verification>
Run the following checks after task completes:

1. **Run all rate limiter tests:**
   ```bash
   pytest tests/test_rate_limiter.py -v
   # Expected: All tests pass
   ```

2. **Check test count:**
   ```bash
   pytest tests/test_rate_limiter.py --collect-only | grep "test_" | wc -l
   # Expected: 20+ tests
   ```

3. **Run with coverage:**
   ```bash
   pytest tests/test_rate_limiter.py --cov=src/middleware/rate_limiter --cov-report=term-missing
   # Expected: High coverage of rate_limiter.py
   ```

4. **Run full test suite:**
   ```bash
   pytest tests/ -v --tb=short -k "not integration"
   # Expected: All tests pass, no regressions
   ```
</verification>

<success_criteria>
- [ ] tests/test_rate_limiter.py exists with 20+ tests
- [ ] InMemoryRateLimitStore tests pass
- [ ] RateLimiter tests pass
- [ ] RateLimitMiddleware tests pass
- [ ] Redis fallback tests pass (using mocks)
- [ ] Tests don't require Redis to run
- [ ] Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-hardening/10-04-SUMMARY.md`
</output>
