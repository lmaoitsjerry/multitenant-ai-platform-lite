---
phase: 11-database-tenant-registry
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/services/tenant_config_service.py
  - config/loader.py
  - src/api/admin_tenants_routes.py
autonomous: true

must_haves:
  truths:
    - "TenantConfigService loads config from database for migrated tenants"
    - "TenantConfigService ignores tn_* auto-generated test tenants"
    - "Existing ClientConfig class continues to work (backward compatible)"
    - "Config cache is cleared when config is updated"
    - "POST /api/admin/tenants creates new tenant records in database"
  artifacts:
    - path: "src/services/tenant_config_service.py"
      provides: "Database-backed tenant configuration service"
      exports: ["TenantConfigService", "get_tenant_config"]
      min_lines: 150
    - path: "config/loader.py"
      provides: "Updated loader using TenantConfigService"
      contains: "TenantConfigService"
    - path: "src/api/admin_tenants_routes.py"
      provides: "Tenant provisioning API endpoint"
      contains: "POST /api/v1/admin/tenants"
  key_links:
    - from: "src/services/tenant_config_service.py"
      to: "supabase.tenants"
      via: "Supabase client query"
      pattern: "table.*tenants.*select"
    - from: "config/loader.py"
      to: "src/services/tenant_config_service.py"
      via: "import and delegation"
      pattern: "from src.services.tenant_config_service import"
    - from: "src/api/admin_tenants_routes.py"
      to: "src/services/tenant_config_service.py"
      via: "import and save_config call"
      pattern: "TenantConfigService.*save_config"
---

<objective>
Create TenantConfigService with database backend and dual-mode operation (DB first, YAML fallback).

Purpose: Enable dynamic tenant management without file deployments. Service queries database for tenant config, falls back to YAML files for tenants not yet migrated (test tenants).

Output: New TenantConfigService class, updated config/loader.py to use it, tenant provisioning API endpoint
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-database-tenant-registry/11-01-SUMMARY.md
@config/loader.py
@database/migrations/012_tenant_config.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TenantConfigService class</name>
  <files>src/services/tenant_config_service.py</files>
  <action>
Create new service file with TenantConfigService class:

```python
"""
Tenant Configuration Service - Database-backed tenant config with YAML fallback

Usage:
    from src.services.tenant_config_service import TenantConfigService, get_tenant_config

    service = TenantConfigService()
    config = service.get_config("tenant_id")  # Returns dict

    # Or use convenience function
    config = get_tenant_config("tenant_id")
"""

import os
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path

import yaml

logger = logging.getLogger(__name__)

class TenantConfigService:
    """
    Tenant configuration service with dual-mode operation:
    1. Try database first (Supabase tenants table)
    2. Fall back to YAML files for unmigrated tenants
    """

    # Real tenants that are migrated to database
    # These are the actual test/development clients we use
    MIGRATED_TENANTS = {
        'africastay',
        'safariexplore-kvph',
        'safarirun-t0vc',
        'beachresorts',
    }

    # tn_* prefixed tenants are auto-generated test data - ignore them
    # They will NOT be migrated and their YAML files can be deleted

    def __init__(self, base_path: Optional[str] = None):
        self.base_path = Path(base_path) if base_path else Path(__file__).parent.parent.parent
        self._supabase = None

    def _get_supabase_client(self):
        """Get or create Supabase client (lazy initialization)"""
        if self._supabase is None:
            url = os.getenv("SUPABASE_URL")
            key = os.getenv("SUPABASE_SERVICE_KEY") or os.getenv("SUPABASE_KEY")

            if url and key:
                try:
                    from supabase import create_client
                    self._supabase = create_client(url, key)
                except Exception as e:
                    logger.warning(f"Could not create Supabase client: {e}")

        return self._supabase

    def get_config(self, tenant_id: str) -> Optional[Dict[str, Any]]:
        """
        Get tenant configuration from database (primary source)

        Args:
            tenant_id: Tenant identifier

        Returns:
            Configuration dict or None if not found
        """
        # Skip tn_* auto-generated test tenants - they're garbage data
        if tenant_id.startswith('tn_'):
            logger.debug(f"Ignoring auto-generated test tenant: {tenant_id}")
            return None

        # Try database first (primary source for migrated tenants)
        config = self._load_from_database(tenant_id)
        if config:
            return config

        # Fall back to YAML only for backward compatibility during migration
        logger.debug(f"Tenant {tenant_id} not in database, falling back to YAML")
        return self._load_from_yaml(tenant_id)

    def _load_from_database(self, tenant_id: str) -> Optional[Dict[str, Any]]:
        """Load config from Supabase tenants table"""
        client = self._get_supabase_client()
        if not client:
            return None

        try:
            result = client.table("tenants").select("*").eq("id", tenant_id).single().execute()

            if not result.data:
                return None

            row = result.data

            # Check if this tenant has database config
            if row.get('config_source') != 'database':
                return None

            # Build config dict from database row
            tenant_config = row.get('tenant_config', {}) or {}

            config = {
                'client': {
                    'id': row['id'],
                    'name': row['name'],
                    'short_name': row.get('short_name', ''),
                    'timezone': row.get('timezone', 'Africa/Johannesburg'),
                    'currency': row.get('currency', 'ZAR'),
                },
                'branding': tenant_config.get('branding', {}),
                'destinations': tenant_config.get('destinations', []),
                'infrastructure': self._build_infrastructure(row, tenant_config),
                'email': self._build_email_config(row, tenant_config),
                'banking': tenant_config.get('banking', {}),
                'consultants': tenant_config.get('consultants', []),
                'agents': tenant_config.get('agents', {}),
            }

            # Add status info
            config['_meta'] = {
                'source': 'database',
                'status': row.get('status', 'active'),
                'plan': row.get('plan', 'lite'),
                'features_enabled': row.get('features_enabled', {}),
            }

            return config

        except Exception as e:
            logger.error(f"Error loading tenant {tenant_id} from database: {e}")
            return None

    def _build_infrastructure(self, row: Dict, tenant_config: Dict) -> Dict[str, Any]:
        """Build infrastructure config, resolving env vars for secrets"""
        infra = tenant_config.get('infrastructure', {})
        tenant_id = row['id']

        # GCP config
        gcp = infra.get('gcp', {})
        gcp['project_id'] = row.get('gcp_project_id') or gcp.get('project_id', os.getenv('GCP_PROJECT_ID', ''))
        gcp['dataset'] = row.get('gcp_dataset') or gcp.get('dataset', '')

        # Supabase - URL from config, keys from env
        supabase = infra.get('supabase', {})
        supabase['url'] = os.getenv('SUPABASE_URL', supabase.get('url', ''))
        supabase['anon_key'] = os.getenv('SUPABASE_ANON_KEY', '')
        supabase['service_key'] = os.getenv('SUPABASE_SERVICE_KEY', '')

        # VAPI - try tenant-specific env var, fall back to config
        vapi = infra.get('vapi', {})
        vapi['api_key'] = os.getenv(f'{tenant_id.upper()}_VAPI_API_KEY') or os.getenv('VAPI_API_KEY', '')

        # OpenAI - shared API key from env
        openai = infra.get('openai', {})
        openai['api_key'] = os.getenv('OPENAI_API_KEY', '')

        return {
            'gcp': gcp,
            'supabase': supabase,
            'vapi': vapi,
            'openai': openai,
        }

    def _build_email_config(self, row: Dict, tenant_config: Dict) -> Dict[str, Any]:
        """Build email config, resolving env vars for API keys"""
        email = tenant_config.get('email', {})
        tenant_id = row['id']

        email['primary'] = row.get('primary_email') or email.get('primary', '')

        # SendGrid - try tenant-specific env var
        sendgrid = email.get('sendgrid', {})
        sendgrid['api_key'] = os.getenv(f'{tenant_id.upper()}_SENDGRID_API_KEY') or os.getenv('SENDGRID_API_KEY', '')
        email['sendgrid'] = sendgrid

        # SMTP password from env
        smtp = email.get('smtp', {})
        smtp['password'] = os.getenv(f'{tenant_id.upper()}_SMTP_PASSWORD') or os.getenv('SMTP_PASSWORD', '')
        email['smtp'] = smtp

        return email

    def _load_from_yaml(self, tenant_id: str) -> Optional[Dict[str, Any]]:
        """Load config from YAML file"""
        config_path = self.base_path / "clients" / tenant_id / "client.yaml"

        if not config_path.exists():
            return None

        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)

            # Substitute env vars
            config = self._substitute_env_vars(config)

            # Add meta info
            config['_meta'] = {
                'source': 'yaml',
                'status': 'active',
            }

            return config

        except Exception as e:
            logger.error(f"Error loading YAML for tenant {tenant_id}: {e}")
            return None

    def _substitute_env_vars(self, obj: Any) -> Any:
        """Recursively substitute ${VAR} and ${VAR:-default} patterns"""
        import re

        if isinstance(obj, dict):
            return {k: self._substitute_env_vars(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._substitute_env_vars(item) for item in obj]
        elif isinstance(obj, str):
            pattern = r'\$\{([A-Z_][A-Z0-9_]*)(?::-([^}]+))?\}'

            def replacer(match):
                var_name = match.group(1)
                default = match.group(2)
                return os.getenv(var_name, default or '')

            return re.sub(pattern, replacer, obj)
        else:
            return obj

    def save_config(self, tenant_id: str, config: Dict[str, Any]) -> bool:
        """
        Save tenant configuration to database

        Args:
            tenant_id: Tenant identifier
            config: Full configuration dict

        Returns:
            True if saved successfully
        """
        client = self._get_supabase_client()
        if not client:
            logger.error("Cannot save config: Supabase client not available")
            return False

        try:
            # Extract core fields for columns
            client_info = config.get('client', {})

            row = {
                'id': tenant_id,
                'name': client_info.get('name', tenant_id),
                'short_name': client_info.get('short_name', ''),
                'timezone': client_info.get('timezone', 'Africa/Johannesburg'),
                'currency': client_info.get('currency', 'ZAR'),
                'primary_email': config.get('email', {}).get('primary', ''),
                'gcp_project_id': config.get('infrastructure', {}).get('gcp', {}).get('project_id', ''),
                'gcp_dataset': config.get('infrastructure', {}).get('gcp', {}).get('dataset', ''),
                'config_source': 'database',
                'tenant_config': self._strip_secrets(config),
            }

            # Upsert (insert or update)
            client.table("tenants").upsert(row, on_conflict='id').execute()

            logger.info(f"Saved config for tenant {tenant_id} to database")
            return True

        except Exception as e:
            logger.error(f"Error saving config for tenant {tenant_id}: {e}")
            return False

    def _strip_secrets(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Remove secrets from config before storing in database"""
        # Deep copy to avoid modifying original
        import copy
        stripped = copy.deepcopy(config)

        # Remove meta
        stripped.pop('_meta', None)

        # Remove client (stored in columns)
        stripped.pop('client', None)

        # Remove secrets from infrastructure
        if 'infrastructure' in stripped:
            infra = stripped['infrastructure']
            if 'supabase' in infra:
                infra['supabase'].pop('anon_key', None)
                infra['supabase'].pop('service_key', None)
            if 'vapi' in infra:
                infra['vapi'].pop('api_key', None)
            if 'openai' in infra:
                infra['openai'].pop('api_key', None)

        # Remove secrets from email
        if 'email' in stripped:
            email = stripped['email']
            if 'sendgrid' in email:
                email['sendgrid'].pop('api_key', None)
            if 'smtp' in email:
                email['smtp'].pop('password', None)

        return stripped

    def list_tenants(self, include_yaml: bool = True) -> List[str]:
        """
        List all available tenant IDs

        Args:
            include_yaml: Include YAML-only tenants in list

        Returns:
            List of tenant IDs
        """
        tenant_ids = set()

        # Get from database
        client = self._get_supabase_client()
        if client:
            try:
                result = client.table("tenants").select("id").eq("status", "active").execute()
                for row in result.data or []:
                    tenant_ids.add(row['id'])
            except Exception as e:
                logger.warning(f"Error listing tenants from database: {e}")

        # Add YAML tenants
        if include_yaml:
            clients_dir = self.base_path / "clients"
            if clients_dir.exists():
                for client_dir in clients_dir.iterdir():
                    if client_dir.is_dir():
                        config_file = client_dir / "client.yaml"
                        if config_file.exists():
                            tenant_ids.add(client_dir.name)

        return sorted(list(tenant_ids))

    def get_tenant_status(self, tenant_id: str) -> str:
        """Get tenant status (active, suspended, deleted)"""
        client = self._get_supabase_client()
        if client:
            try:
                result = client.table("tenants").select("status").eq("id", tenant_id).single().execute()
                if result.data:
                    return result.data.get('status', 'active')
            except Exception:
                pass
        return 'active'  # Default for YAML tenants


# Module-level convenience functions
_service_instance: Optional[TenantConfigService] = None

def get_service() -> TenantConfigService:
    """Get or create singleton service instance"""
    global _service_instance
    if _service_instance is None:
        _service_instance = TenantConfigService()
    return _service_instance

def get_tenant_config(tenant_id: str) -> Optional[Dict[str, Any]]:
    """Convenience function to get tenant config"""
    return get_service().get_config(tenant_id)

def list_all_tenants() -> List[str]:
    """Convenience function to list all tenants"""
    return get_service().list_tenants()
```

Key design decisions:
- YAML_ONLY_TENANTS set explicitly lists test tenants that won't be migrated
- Lazy Supabase client initialization
- Secrets resolved from environment variables at runtime, not stored in DB
- _meta field indicates config source for debugging
- save_config strips secrets before storing
  </action>
  <verify>
- File exists at src/services/tenant_config_service.py
- Imports work: `python -c "from src.services.tenant_config_service import TenantConfigService"`
- MIGRATED_TENANTS contains: africastay, safariexplore-kvph, safarirun-t0vc, beachresorts
- tn_* tenants are ignored (auto-generated test data)
  </verify>
  <done>
TenantConfigService class created with:
- get_config() with dual-mode operation
- save_config() for database persistence
- list_tenants() for tenant discovery
- Proper secret handling (env vars, not DB)
- YAML fallback for test tenants
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config/loader.py to use TenantConfigService</name>
  <files>config/loader.py</files>
  <action>
Update the existing config/loader.py to use TenantConfigService as its backend while maintaining full backward compatibility:

1. Add import at top:
```python
from src.services.tenant_config_service import TenantConfigService, get_service as get_config_service
```

2. Modify ClientConfig.__init__ to try TenantConfigService first:
```python
def __init__(self, client_id: str, base_path: Optional[str] = None):
    self.client_id = client_id

    if base_path is None:
        base_path = Path(__file__).parent.parent

    self.base_path = Path(base_path)
    self.config_path = self.base_path / "clients" / client_id / "client.yaml"
    self.schema_path = self.base_path / "config" / "schema.json"

    # Try TenantConfigService first (database + YAML fallback)
    try:
        service = get_config_service()
        config = service.get_config(client_id)
        if config:
            self.config = config
            self._config_source = config.get('_meta', {}).get('source', 'service')
            return
    except Exception as e:
        import logging
        logging.getLogger(__name__).debug(f"TenantConfigService unavailable: {e}")

    # Direct YAML fallback (original behavior)
    if not self.config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {self.config_path}")

    self.config = self._load_config()
    self._config_source = 'yaml'
    self._validate_config()
```

3. Add property to check config source:
```python
@property
def config_source(self) -> str:
    """Source of configuration: 'database', 'yaml', or 'service'"""
    return getattr(self, '_config_source', 'yaml')
```

4. Update list_clients() to use TenantConfigService:
```python
def list_clients() -> List[str]:
    """List all available client IDs"""
    try:
        service = get_config_service()
        return service.list_tenants()
    except Exception:
        # Fallback to filesystem scan
        clients_dir = Path(__file__).parent.parent / "clients"
        if not clients_dir.exists():
            return []

        client_ids = []
        for client_dir in clients_dir.iterdir():
            if client_dir.is_dir():
                config_file = client_dir / "client.yaml"
                if config_file.exists():
                    client_ids.append(client_dir.name)

        return sorted(client_ids)
```

5. Update clear_config_cache() to also clear service cache:
```python
def clear_config_cache(client_id: str = None):
    """Clear the config cache"""
    global _config_cache
    if client_id:
        _config_cache.pop(client_id, None)
    else:
        _config_cache = {}

    # Also reset service instance to force refresh
    import src.services.tenant_config_service as tcs
    tcs._service_instance = None
```

6. Skip validation for database-sourced configs (already validated on save):
```python
# In __init__, after loading from service:
if config:
    self.config = config
    self._config_source = config.get('_meta', {}).get('source', 'service')
    # Skip validation for database configs (validated on save)
    if self._config_source != 'database':
        self._validate_config()
    return
```

Maintain ALL existing properties (name, short_name, timezone, etc.) - they read from self.config which is now populated by TenantConfigService.
  </action>
  <verify>
- config/loader.py imports TenantConfigService
- Existing tests pass: `python -m pytest tests/test_config.py -v`
- ClientConfig still works: `python -c "from config.loader import ClientConfig; c = ClientConfig('africastay'); print(c.name)"`
  </verify>
  <done>
config/loader.py updated with:
- TenantConfigService integration (DB first, YAML fallback)
- config_source property for debugging
- list_clients() uses TenantConfigService
- clear_config_cache() resets service instance
- Full backward compatibility maintained
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tenant provisioning API endpoint</name>
  <files>src/api/admin_tenants_routes.py</files>
  <action>
Add a POST endpoint to create new tenants via HTTP API, using TenantConfigService.save_config():

1. Add import at top of file:
```python
from src.services.tenant_config_service import TenantConfigService, get_service as get_config_service
```

2. Add Pydantic model for tenant creation request:
```python
class CreateTenantRequest(BaseModel):
    """Request to create a new tenant"""
    tenant_id: str = Field(..., min_length=3, max_length=50, pattern=r'^[a-z0-9_-]+$')
    company_name: str = Field(..., min_length=2, max_length=100)
    admin_email: str = Field(..., description="Primary admin email")
    timezone: str = Field(default="Africa/Johannesburg")
    currency: str = Field(default="ZAR")
    plan: str = Field(default="lite", description="Subscription plan: lite, standard, premium")

    # Optional branding
    logo_url: Optional[str] = None
    primary_color: Optional[str] = Field(default="#1a73e8")

    # Optional infrastructure
    gcp_project_id: Optional[str] = None
    gcp_dataset: Optional[str] = None
```

3. Add POST endpoint after the list endpoint (before /{tenant_id} routes):
```python
@admin_tenants_router.post("", status_code=201)
async def create_tenant(
    request: CreateTenantRequest,
    admin_verified: bool = Depends(verify_admin_token)
):
    """
    Create a new tenant in the database.

    This endpoint provisions a new tenant without requiring YAML file deployment.
    The tenant configuration is stored directly in the database.

    Returns the created tenant details.
    """
    try:
        # Check if tenant already exists
        service = get_config_service()
        existing = service.get_config(request.tenant_id)
        if existing:
            raise HTTPException(
                status_code=409,
                detail=f"Tenant {request.tenant_id} already exists"
            )

        # Build tenant configuration
        config = {
            'client': {
                'id': request.tenant_id,
                'name': request.company_name,
                'short_name': request.tenant_id[:10].upper(),
                'timezone': request.timezone,
                'currency': request.currency,
            },
            'branding': {
                'company_name': request.company_name,
                'logo_url': request.logo_url,
                'primary_color': request.primary_color or '#1a73e8',
            },
            'email': {
                'primary': request.admin_email,
            },
            'infrastructure': {
                'gcp': {
                    'project_id': request.gcp_project_id or '',
                    'dataset': request.gcp_dataset or '',
                },
            },
            'destinations': [],
            'consultants': [],
            'agents': {
                'inbound': {'enabled': False},
                'helpdesk': {'enabled': True},
                'outbound': {'enabled': False},
            },
        }

        # Save to database
        success = service.save_config(request.tenant_id, config)
        if not success:
            raise HTTPException(
                status_code=500,
                detail="Failed to save tenant configuration to database"
            )

        # Also insert into tenants table with full metadata
        client = get_supabase_admin_client()
        if client:
            try:
                # Update with additional fields not in tenant_config
                client.table("tenants").update({
                    'admin_email': request.admin_email,
                    'support_email': request.admin_email,
                    'status': 'active',
                    'plan': request.plan,
                    'max_users': 5 if request.plan == 'lite' else 20,
                    'max_monthly_quotes': 100 if request.plan == 'lite' else 1000,
                    'max_storage_gb': 1 if request.plan == 'lite' else 10,
                    'features_enabled': {
                        'ai_helpdesk': True,
                        'email_quotes': True,
                        'voice_calls': request.plan != 'lite',
                    },
                }).eq('id', request.tenant_id).execute()
            except Exception as e:
                logger.warning(f"Could not update additional tenant fields: {e}")

        logger.info(f"[ADMIN] Created new tenant: {request.tenant_id}")

        return {
            "success": True,
            "message": f"Tenant {request.tenant_id} created successfully",
            "data": {
                "tenant_id": request.tenant_id,
                "company_name": request.company_name,
                "admin_email": request.admin_email,
                "plan": request.plan,
                "status": "active",
                "config_source": "database",
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        log_and_raise(500, f"creating tenant {request.tenant_id}", e, logger)
```

Key points:
- Uses TenantConfigService.save_config() to create database record
- Returns 409 Conflict if tenant already exists
- Sets default plan limits based on subscription tier
- No YAML file created - pure database provisioning
  </action>
  <verify>
- Endpoint exists: `grep -n "def create_tenant" src/api/admin_tenants_routes.py`
- Import added: `grep "TenantConfigService" src/api/admin_tenants_routes.py`
- Test with curl (requires admin token): `curl -X POST http://localhost:8000/api/v1/admin/tenants -H "X-Admin-Token: $ADMIN_TOKEN" -H "Content-Type: application/json" -d '{"tenant_id": "test_new", "company_name": "Test Company", "admin_email": "admin@test.com"}'`
  </verify>
  <done>
Tenant provisioning API endpoint created:
- POST /api/v1/admin/tenants accepts tenant configuration
- Calls TenantConfigService.save_config() to create database record
- No YAML file deployment needed
- Returns 409 if tenant already exists
- Sets plan-based limits (users, quotes, storage)
  </done>
</task>

</tasks>

<verification>
- [ ] src/services/tenant_config_service.py exists with TenantConfigService class
- [ ] config/loader.py imports and uses TenantConfigService
- [ ] YAML-only tenants (africastay, etc.) still load from YAML
- [ ] Database-configured tenants load from database
- [ ] Secrets resolved from environment variables, not stored in DB
- [ ] Existing ClientConfig API unchanged (all properties work)
- [ ] tests/test_config.py passes
- [ ] POST /api/v1/admin/tenants endpoint exists and creates tenants in database
- [ ] Tenant provisioning does not require YAML file deployment
</verification>

<success_criteria>
1. TenantConfigService.get_config() returns config from database when available
2. TenantConfigService.get_config() falls back to YAML when database record missing
3. ClientConfig class works exactly as before (backward compatible)
4. Test tenants (africastay, etc.) always load from YAML
5. Secrets never stored in database, always resolved from env vars
6. POST /api/v1/admin/tenants creates new tenant records in database via TenantConfigService.save_config()
</success_criteria>

<output>
After completion, create `.planning/phases/11-database-tenant-registry/11-02-SUMMARY.md`
</output>
