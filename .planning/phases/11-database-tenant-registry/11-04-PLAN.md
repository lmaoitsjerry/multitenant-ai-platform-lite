---
phase: 11-database-tenant-registry
plan: 04
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - src/services/tenant_config_service.py
  - tests/test_tenant_config_service.py
autonomous: true

must_haves:
  truths:
    - "Tenant config lookups are cached in Redis with TTL"
    - "Cache is invalidated when config is updated"
    - "System works without Redis (graceful fallback)"
    - "Unit tests verify tenant isolation at database level"
  artifacts:
    - path: "src/services/tenant_config_service.py"
      provides: "Redis caching for tenant config"
      contains: "redis"
    - path: "tests/test_tenant_config_service.py"
      provides: "Unit tests for tenant config service"
      min_lines: 100
  key_links:
    - from: "src/services/tenant_config_service.py"
      to: "redis"
      via: "Redis client get/set"
      pattern: "redis.*get|redis.*set"
    - from: "tests/test_tenant_config_service.py"
      to: "src/services/tenant_config_service.py"
      via: "pytest imports"
      pattern: "from src.services.tenant_config_service import"
---

<objective>
Add Redis caching to TenantConfigService and create unit tests for tenant isolation.

Purpose: Reduce database load by caching tenant configurations in Redis with TTL. Ensure robust testing of tenant isolation to satisfy TEST-03 requirement.

Output: Updated TenantConfigService with Redis caching, comprehensive unit tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-database-tenant-registry/11-02-SUMMARY.md
@src/services/tenant_config_service.py
@src/middleware/rate_limiter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis caching to TenantConfigService</name>
  <files>src/services/tenant_config_service.py</files>
  <action>
Update TenantConfigService to add Redis caching for tenant config lookups:

1. Add Redis client initialization (similar to rate_limiter.py pattern):
```python
import json
from typing import Dict, Any, List, Optional

class TenantConfigService:
    """..."""

    # Cache TTL in seconds (5 minutes)
    CACHE_TTL = 300

    # Cache key prefix
    CACHE_PREFIX = "tenant_config:"

    def __init__(self, base_path: Optional[str] = None):
        self.base_path = Path(base_path) if base_path else Path(__file__).parent.parent.parent
        self._supabase = None
        self._redis = None
        self._redis_available = None  # Lazy check

    def _get_redis_client(self):
        """Get Redis client for caching (lazy initialization with fallback)"""
        if self._redis_available is False:
            return None

        if self._redis is None:
            redis_url = os.getenv("REDIS_URL")
            if redis_url:
                try:
                    import redis
                    self._redis = redis.from_url(redis_url)
                    self._redis.ping()
                    self._redis_available = True
                    logger.info("Redis cache connected for tenant config")
                except Exception as e:
                    logger.warning(f"Redis not available for tenant config cache: {e}")
                    self._redis_available = False
                    self._redis = None
            else:
                self._redis_available = False

        return self._redis
```

2. Add cache methods:
```python
def _cache_key(self, tenant_id: str) -> str:
    """Generate cache key for tenant"""
    return f"{self.CACHE_PREFIX}{tenant_id}"

def _get_from_cache(self, tenant_id: str) -> Optional[Dict[str, Any]]:
    """Get tenant config from Redis cache"""
    redis = self._get_redis_client()
    if not redis:
        return None

    try:
        key = self._cache_key(tenant_id)
        data = redis.get(key)
        if data:
            logger.debug(f"Cache hit for tenant {tenant_id}")
            return json.loads(data)
    except Exception as e:
        logger.warning(f"Redis cache read error: {e}")

    return None

def _set_cache(self, tenant_id: str, config: Dict[str, Any]):
    """Store tenant config in Redis cache"""
    redis = self._get_redis_client()
    if not redis:
        return

    try:
        key = self._cache_key(tenant_id)
        # Don't cache secrets - they're resolved at runtime anyway
        redis.setex(key, self.CACHE_TTL, json.dumps(config))
        logger.debug(f"Cached config for tenant {tenant_id} (TTL: {self.CACHE_TTL}s)")
    except Exception as e:
        logger.warning(f"Redis cache write error: {e}")

def _invalidate_cache(self, tenant_id: str):
    """Remove tenant config from cache"""
    redis = self._get_redis_client()
    if not redis:
        return

    try:
        key = self._cache_key(tenant_id)
        redis.delete(key)
        logger.debug(f"Invalidated cache for tenant {tenant_id}")
    except Exception as e:
        logger.warning(f"Redis cache delete error: {e}")

def invalidate_all_cache(self):
    """Clear all tenant config cache entries"""
    redis = self._get_redis_client()
    if not redis:
        return

    try:
        # Find and delete all tenant config keys
        pattern = f"{self.CACHE_PREFIX}*"
        cursor = 0
        while True:
            cursor, keys = redis.scan(cursor, match=pattern, count=100)
            if keys:
                redis.delete(*keys)
            if cursor == 0:
                break
        logger.info("Invalidated all tenant config cache")
    except Exception as e:
        logger.warning(f"Redis cache clear error: {e}")
```

3. Update get_config() to use cache:
```python
def get_config(self, tenant_id: str) -> Optional[Dict[str, Any]]:
    """
    Get tenant configuration (cache -> database -> YAML fallback)
    """
    # Check if YAML-only tenant (skip cache for these)
    if tenant_id in self.YAML_ONLY_TENANTS:
        return self._load_from_yaml(tenant_id)

    # Try cache first
    cached = self._get_from_cache(tenant_id)
    if cached:
        return cached

    # Try database
    config = self._load_from_database(tenant_id)
    if config:
        self._set_cache(tenant_id, config)
        return config

    # Fall back to YAML
    logger.debug(f"Tenant {tenant_id} not in database, falling back to YAML")
    yaml_config = self._load_from_yaml(tenant_id)
    if yaml_config:
        # Cache YAML config too (shorter TTL for YAML since it might be outdated)
        self._set_cache(tenant_id, yaml_config)
    return yaml_config
```

4. Update save_config() to invalidate cache:
```python
def save_config(self, tenant_id: str, config: Dict[str, Any]) -> bool:
    """Save tenant configuration to database and invalidate cache"""
    # ... existing save logic ...

    # After successful save:
    self._invalidate_cache(tenant_id)
    logger.info(f"Saved config for tenant {tenant_id} to database")
    return True
```

5. Add cache info method:
```python
def get_cache_info(self) -> Dict[str, Any]:
    """Get information about cache status"""
    redis = self._get_redis_client()
    if not redis:
        return {
            'backend': 'none',
            'available': False,
            'ttl_seconds': self.CACHE_TTL,
        }

    try:
        # Count cached tenants
        pattern = f"{self.CACHE_PREFIX}*"
        cursor, keys = redis.scan(0, match=pattern, count=1000)
        count = len(keys)

        return {
            'backend': 'redis',
            'available': True,
            'ttl_seconds': self.CACHE_TTL,
            'cached_tenants': count,
        }
    except Exception:
        return {
            'backend': 'redis',
            'available': False,
            'ttl_seconds': self.CACHE_TTL,
        }
```
  </action>
  <verify>
- File compiles: `python -m py_compile src/services/tenant_config_service.py`
- Redis methods exist: `python -c "from src.services.tenant_config_service import TenantConfigService; t = TenantConfigService(); print(hasattr(t, '_get_from_cache'))"`
  </verify>
  <done>
TenantConfigService updated with:
- Redis cache integration (CACHE_TTL = 300 seconds)
- Cache check before database lookup
- Cache invalidation on save_config()
- Graceful fallback when Redis unavailable
- get_cache_info() for monitoring
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for TenantConfigService</name>
  <files>tests/test_tenant_config_service.py</files>
  <action>
Create comprehensive unit tests for TenantConfigService:

```python
"""
Unit Tests for TenantConfigService

Tests cover:
- Database-backed config loading
- YAML fallback behavior
- Tenant isolation (critical for multi-tenant security)
- Cache behavior
- Secret handling (not stored in database)
"""

import os
import json
import pytest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path

# Import the service
from src.services.tenant_config_service import (
    TenantConfigService,
    get_tenant_config,
    list_all_tenants,
)


class TestTenantConfigService:
    """Test TenantConfigService core functionality"""

    def test_yaml_only_tenants_constant(self):
        """Verify YAML-only tenants are correctly defined"""
        service = TenantConfigService()
        expected = {'africastay', 'safariexplore-kvph', 'safarirun-t0vc', 'beachresorts', 'example'}
        assert service.YAML_ONLY_TENANTS == expected

    def test_cache_prefix_defined(self):
        """Verify cache prefix is defined"""
        service = TenantConfigService()
        assert service.CACHE_PREFIX == "tenant_config:"
        assert service.CACHE_TTL == 300

    def test_cache_key_generation(self):
        """Test cache key generation"""
        service = TenantConfigService()
        key = service._cache_key("tn_123456")
        assert key == "tenant_config:tn_123456"


class TestYamlFallback:
    """Test YAML fallback behavior"""

    def test_yaml_only_tenant_skips_database(self):
        """YAML-only tenants should not query database"""
        service = TenantConfigService()

        with patch.object(service, '_load_from_database') as mock_db:
            with patch.object(service, '_load_from_yaml') as mock_yaml:
                mock_yaml.return_value = {'client': {'id': 'africastay'}}

                config = service.get_config('africastay')

                # Database should NOT be called for YAML-only tenant
                mock_db.assert_not_called()
                mock_yaml.assert_called_once_with('africastay')

    def test_production_tenant_tries_database_first(self):
        """Production tenants should try database first"""
        service = TenantConfigService()

        with patch.object(service, '_get_from_cache', return_value=None):
            with patch.object(service, '_load_from_database') as mock_db:
                with patch.object(service, '_set_cache'):
                    mock_db.return_value = {'client': {'id': 'tn_123'}}

                    config = service.get_config('tn_123')

                    mock_db.assert_called_once_with('tn_123')

    def test_yaml_fallback_when_database_empty(self):
        """Falls back to YAML when database returns None"""
        service = TenantConfigService()

        with patch.object(service, '_get_from_cache', return_value=None):
            with patch.object(service, '_load_from_database', return_value=None):
                with patch.object(service, '_load_from_yaml') as mock_yaml:
                    with patch.object(service, '_set_cache'):
                        mock_yaml.return_value = {'client': {'id': 'tn_unknown'}}

                        config = service.get_config('tn_unknown')

                        mock_yaml.assert_called_once_with('tn_unknown')


class TestTenantIsolation:
    """
    Critical tests for tenant isolation (TEST-03 requirement)

    These tests verify that one tenant cannot access another tenant's data.
    """

    def test_different_tenants_get_different_configs(self):
        """Each tenant must receive their own configuration"""
        service = TenantConfigService()

        tenant_a_config = {'client': {'id': 'tenant_a', 'name': 'Tenant A'}}
        tenant_b_config = {'client': {'id': 'tenant_b', 'name': 'Tenant B'}}

        with patch.object(service, '_get_from_cache', return_value=None):
            with patch.object(service, '_load_from_database') as mock_db:
                with patch.object(service, '_set_cache'):
                    # Return different configs for different tenants
                    mock_db.side_effect = lambda tid: tenant_a_config if tid == 'tenant_a' else tenant_b_config

                    config_a = service.get_config('tenant_a')
                    config_b = service.get_config('tenant_b')

                    assert config_a['client']['id'] == 'tenant_a'
                    assert config_b['client']['id'] == 'tenant_b'
                    assert config_a != config_b

    def test_tenant_id_in_database_query(self):
        """Verify tenant_id is used in database query"""
        service = TenantConfigService()

        mock_supabase = MagicMock()
        mock_table = MagicMock()
        mock_select = MagicMock()
        mock_eq = MagicMock()
        mock_single = MagicMock()

        mock_supabase.table.return_value = mock_table
        mock_table.select.return_value = mock_select
        mock_select.eq.return_value = mock_eq
        mock_eq.single.return_value = mock_single
        mock_single.execute.return_value = MagicMock(data=None)

        with patch.object(service, '_get_supabase_client', return_value=mock_supabase):
            service._load_from_database('specific_tenant_123')

            # Verify the query filters by tenant_id
            mock_table.select.assert_called_with("*")
            mock_select.eq.assert_called_with("id", "specific_tenant_123")

    def test_cache_keys_are_tenant_specific(self):
        """Cache keys must include tenant_id to prevent cross-tenant leakage"""
        service = TenantConfigService()

        key_a = service._cache_key('tenant_a')
        key_b = service._cache_key('tenant_b')

        assert 'tenant_a' in key_a
        assert 'tenant_b' in key_b
        assert key_a != key_b

    def test_save_config_only_affects_specified_tenant(self):
        """save_config must only update the specified tenant"""
        service = TenantConfigService()

        mock_supabase = MagicMock()
        mock_table = MagicMock()
        mock_upsert = MagicMock()

        mock_supabase.table.return_value = mock_table
        mock_table.upsert.return_value = mock_upsert
        mock_upsert.execute.return_value = MagicMock()

        with patch.object(service, '_get_supabase_client', return_value=mock_supabase):
            with patch.object(service, '_invalidate_cache'):
                service.save_config('target_tenant', {'client': {'id': 'target_tenant'}})

                # Verify upsert was called with correct tenant_id
                call_args = mock_table.upsert.call_args
                row_data = call_args[0][0]
                assert row_data['id'] == 'target_tenant'


class TestSecretHandling:
    """Test that secrets are properly handled (not stored in DB)"""

    def test_strip_secrets_removes_api_keys(self):
        """Secrets should be stripped before database storage"""
        service = TenantConfigService()

        config = {
            'client': {'id': 'test'},
            'infrastructure': {
                'supabase': {'url': 'https://x.supabase.co', 'anon_key': 'secret123', 'service_key': 'secret456'},
                'vapi': {'api_key': 'vapi_secret', 'assistant_id': 'ast_123'},
                'openai': {'api_key': 'sk-secret', 'model': 'gpt-4o-mini'},
            },
            'email': {
                'primary': 'test@example.com',
                'sendgrid': {'api_key': 'SG.secret', 'from_email': 'noreply@example.com'},
                'smtp': {'host': 'smtp.example.com', 'password': 'smtp_secret'},
            },
        }

        stripped = service._strip_secrets(config)

        # Secrets should be removed
        assert 'anon_key' not in stripped.get('infrastructure', {}).get('supabase', {})
        assert 'service_key' not in stripped.get('infrastructure', {}).get('supabase', {})
        assert 'api_key' not in stripped.get('infrastructure', {}).get('vapi', {})
        assert 'api_key' not in stripped.get('infrastructure', {}).get('openai', {})
        assert 'api_key' not in stripped.get('email', {}).get('sendgrid', {})
        assert 'password' not in stripped.get('email', {}).get('smtp', {})

        # Non-secrets should remain
        assert stripped['infrastructure']['vapi']['assistant_id'] == 'ast_123'
        assert stripped['infrastructure']['openai']['model'] == 'gpt-4o-mini'
        assert stripped['email']['sendgrid']['from_email'] == 'noreply@example.com'

    def test_secrets_resolved_from_env_vars(self):
        """Secrets should be resolved from environment variables"""
        service = TenantConfigService()

        # Mock database row
        row = {
            'id': 'test_tenant',
            'name': 'Test Tenant',
            'config_source': 'database',
            'tenant_config': {
                'infrastructure': {
                    'openai': {'model': 'gpt-4o-mini'},
                    'vapi': {'assistant_id': 'ast_123'},
                },
            },
        }

        with patch.dict(os.environ, {'OPENAI_API_KEY': 'env_openai_key', 'VAPI_API_KEY': 'env_vapi_key'}):
            infra = service._build_infrastructure(row, row['tenant_config'])

            assert infra['openai']['api_key'] == 'env_openai_key'
            assert infra['vapi']['api_key'] == 'env_vapi_key'


class TestCacheBehavior:
    """Test Redis cache behavior"""

    def test_cache_hit_skips_database(self):
        """When cache hit, database should not be queried"""
        service = TenantConfigService()

        cached_config = {'client': {'id': 'cached_tenant'}, '_meta': {'source': 'database'}}

        with patch.object(service, '_get_from_cache', return_value=cached_config):
            with patch.object(service, '_load_from_database') as mock_db:
                config = service.get_config('tn_cached')

                # Database should NOT be called on cache hit
                mock_db.assert_not_called()
                assert config == cached_config

    def test_cache_miss_queries_database(self):
        """When cache miss, database should be queried"""
        service = TenantConfigService()

        db_config = {'client': {'id': 'db_tenant'}}

        with patch.object(service, '_get_from_cache', return_value=None):
            with patch.object(service, '_load_from_database', return_value=db_config):
                with patch.object(service, '_set_cache') as mock_set:
                    config = service.get_config('tn_db')

                    # Cache should be populated after DB hit
                    mock_set.assert_called_once_with('tn_db', db_config)

    def test_save_invalidates_cache(self):
        """Saving config should invalidate cache"""
        service = TenantConfigService()

        mock_supabase = MagicMock()
        mock_supabase.table.return_value.upsert.return_value.execute.return_value = MagicMock()

        with patch.object(service, '_get_supabase_client', return_value=mock_supabase):
            with patch.object(service, '_invalidate_cache') as mock_invalidate:
                service.save_config('tenant_x', {'client': {'id': 'tenant_x'}})

                mock_invalidate.assert_called_once_with('tenant_x')

    def test_graceful_fallback_when_redis_unavailable(self):
        """System should work when Redis is not available"""
        service = TenantConfigService()
        service._redis_available = False  # Simulate Redis unavailable

        with patch.object(service, '_load_from_database') as mock_db:
            with patch.object(service, '_set_cache') as mock_set:
                mock_db.return_value = {'client': {'id': 'test'}}

                config = service.get_config('tn_test')

                # Should still work, just without caching
                assert config is not None


class TestEnvVarSubstitution:
    """Test environment variable substitution in YAML configs"""

    def test_env_var_substitution_simple(self):
        """Test ${VAR} substitution"""
        service = TenantConfigService()

        with patch.dict(os.environ, {'TEST_VAR': 'test_value'}):
            result = service._substitute_env_vars('prefix_${TEST_VAR}_suffix')
            assert result == 'prefix_test_value_suffix'

    def test_env_var_substitution_with_default(self):
        """Test ${VAR:-default} substitution"""
        service = TenantConfigService()

        # Ensure var is not set
        os.environ.pop('UNSET_VAR', None)

        result = service._substitute_env_vars('${UNSET_VAR:-default_value}')
        assert result == 'default_value'

    def test_env_var_substitution_recursive(self):
        """Test substitution in nested structures"""
        service = TenantConfigService()

        with patch.dict(os.environ, {'KEY1': 'value1', 'KEY2': 'value2'}):
            config = {
                'level1': {
                    'nested': '${KEY1}',
                    'list': ['${KEY2}', 'static'],
                },
            }

            result = service._substitute_env_vars(config)

            assert result['level1']['nested'] == 'value1'
            assert result['level1']['list'][0] == 'value2'
            assert result['level1']['list'][1] == 'static'


class TestListTenants:
    """Test tenant listing functionality"""

    def test_list_includes_database_tenants(self):
        """list_tenants should include database tenants"""
        service = TenantConfigService()

        mock_supabase = MagicMock()
        mock_supabase.table.return_value.select.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[{'id': 'tn_001'}, {'id': 'tn_002'}]
        )

        with patch.object(service, '_get_supabase_client', return_value=mock_supabase):
            with patch('pathlib.Path.exists', return_value=False):
                tenants = service.list_tenants(include_yaml=False)

                assert 'tn_001' in tenants
                assert 'tn_002' in tenants


# Run tests
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```
  </action>
  <verify>
- Test file exists: `ls tests/test_tenant_config_service.py`
- Tests pass: `python -m pytest tests/test_tenant_config_service.py -v`
  </verify>
  <done>
Unit tests created covering:
- YAML-only tenant handling
- Database-first lookup with YAML fallback
- Tenant isolation (critical security tests)
- Secret stripping (not stored in DB)
- Cache behavior (hit, miss, invalidation)
- Environment variable substitution
- Graceful Redis fallback
  </done>
</task>

</tasks>

<verification>
- [ ] Redis caching added to TenantConfigService
- [ ] Cache TTL = 300 seconds (5 minutes)
- [ ] Cache invalidation on save_config()
- [ ] Graceful fallback when Redis unavailable
- [ ] Unit tests exist at tests/test_tenant_config_service.py
- [ ] Tests cover tenant isolation (TEST-03)
- [ ] Tests pass: `pytest tests/test_tenant_config_service.py -v`
</verification>

<success_criteria>
1. Tenant config lookups are cached in Redis with 5-minute TTL
2. Cache is invalidated when save_config() is called
3. System works without Redis (falls back to direct DB/YAML lookup)
4. Unit tests verify tenant isolation at database level
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-database-tenant-registry/11-04-SUMMARY.md`
</output>
