---
phase: 08-security-and-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/auth_service.py
  - config/loader.py
autonomous: true

must_haves:
  truths:
    - "JWT tokens are cryptographically verified before granting access"
    - "Invalid/tampered tokens are rejected with 401"
    - "Expired tokens are rejected with appropriate error message"
  artifacts:
    - path: "src/services/auth_service.py"
      provides: "JWT signature verification with SUPABASE_JWT_SECRET"
      contains: "verify_signature.*True"
  key_links:
    - from: "src/services/auth_service.py"
      to: "SUPABASE_JWT_SECRET env var"
      via: "os.getenv for secret retrieval"
      pattern: "os\\.getenv.*JWT_SECRET"
---

<objective>
Enable JWT signature verification to fix critical security vulnerability.

Purpose: Currently JWT tokens are NOT cryptographically verified (verify_signature=False). This means anyone can forge a valid-looking JWT without knowing the secret. This is a critical security vulnerability that must be fixed immediately.

Output: JWT tokens are properly verified using the Supabase JWT secret before granting access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/auth_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable JWT signature verification</name>
  <files>src/services/auth_service.py</files>
  <action>
Modify the `verify_jwt` method (around line 190-230) to enable proper signature verification:

1. Change `verify_signature` from `False` to `True`

2. Update the jwt.decode call to include:
   - The `self.jwt_secret` as the key parameter
   - Add `algorithms=["HS256"]` since Supabase uses HS256

3. The method should look like:
```python
def verify_jwt(self, token: str) -> Tuple[bool, Dict[str, Any]]:
    """
    Verify and decode JWT token with cryptographic signature verification.
    """
    try:
        payload = jwt.decode(
            token,
            self.jwt_secret,
            algorithms=["HS256"],
            options={
                "verify_signature": True,
                "verify_exp": True,
                "verify_aud": False,  # Supabase audience varies
            }
        )

        # Validate required claims
        if not payload.get("sub"):
            return False, {"error": "Invalid token: missing subject"}

        if not payload.get("exp"):
            return False, {"error": "Invalid token: missing expiration"}

        return True, payload

    except jwt.ExpiredSignatureError:
        return False, {"error": "Token expired"}
    except jwt.InvalidSignatureError:
        logger.warning("JWT signature verification failed - possible token tampering")
        return False, {"error": "Invalid token signature"}
    except jwt.InvalidTokenError as e:
        logger.error(f"Invalid JWT: {e}")
        return False, {"error": "Invalid token"}
    except Exception as e:
        logger.error(f"Error verifying JWT: {e}")
        return False, {"error": "Token verification failed"}
```

4. Update the comment above the method to indicate signature verification is now enabled

5. Remove the misleading comment about "skipping signature verification for performance" - the performance impact is negligible (microseconds)
  </action>
  <verify>
Run: `grep -n "verify_signature" src/services/auth_service.py` - should show `True`
Run: `grep -n "algorithms" src/services/auth_service.py` - should show `HS256`
  </verify>
  <done>
JWT signature verification is enabled with HS256 algorithm. Invalid signatures will be rejected with a clear error message.
  </done>
</task>

<task type="auto">
  <name>Task 2: Ensure JWT secret is properly configured</name>
  <files>src/services/auth_service.py</files>
  <action>
1. Update the `__init__` method to validate the JWT secret is available:
   - Log a warning if `SUPABASE_JWT_SECRET` is not set
   - Fall back to supabase_key only if JWT_SECRET is not available (with warning)

2. Add a comment explaining how to get the JWT secret:
```python
# JWT Secret: Found in Supabase Dashboard > Project Settings > API > JWT Secret
# Should be set as SUPABASE_JWT_SECRET environment variable
self.jwt_secret = os.getenv("SUPABASE_JWT_SECRET")
if not self.jwt_secret:
    logger.warning(
        "SUPABASE_JWT_SECRET not set - falling back to service key. "
        "For production, set SUPABASE_JWT_SECRET from Supabase Dashboard > Project Settings > API"
    )
    self.jwt_secret = supabase_key
```

3. This ensures the system still works in development but warns about proper configuration
  </action>
  <verify>
Run: `grep -n "SUPABASE_JWT_SECRET" src/services/auth_service.py` - should show the env var lookup
  </verify>
  <done>
JWT secret is properly loaded from environment with fallback and warning for development environments.
  </done>
</task>

</tasks>

<verification>
1. JWT verification enabled: `grep "verify_signature.*True" src/services/auth_service.py`
2. HS256 algorithm specified: `grep "HS256" src/services/auth_service.py`
3. JWT secret env var used: `grep "SUPABASE_JWT_SECRET" src/services/auth_service.py`
4. No syntax errors: `python -c "from src.services.auth_service import AuthService; print('OK')"`
</verification>

<success_criteria>
- JWT tokens are verified with cryptographic signature before granting access
- Invalid/tampered tokens return 401 with "Invalid token signature" error
- Expired tokens return 401 with "Token expired" error
- System logs warning if SUPABASE_JWT_SECRET is not configured
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-and-fixes/08-01-SUMMARY.md`
</output>
